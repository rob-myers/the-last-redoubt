---
key: index
date: 2023-06-01
info: Home page
# ⛔️ GraphQL error avoided if ≥ 1 instance of field
giscusTerm: /home
label: home
navGroup: null
next: intro/
path: /
prev: null
tags:
  - cli
  - web dev
  - behaviour
  - video games
---

import Carousel from "components/page/Carousel";
import Icon, { RoadWorksIcon } from "components/page/Icon";
import InlineCode from "components/page/InlineCode";
import SideNote from "components/page/SideNote";
import Tabs from "components/page/Tabs";
import Aside from "components/page/Aside";
import { ansi } from "projects/sh/util";

## home

### Introduction

We want to make video games more meaningful. That is the objective of this website. Video games suffer from an underlying problem: **simplistic character behaviour** (NPC as a [meme](https://en.wikipedia.org/wiki/NPC_(meme))). Exceptional games have circumvented this, recent examples being:
- [What Remains of Edith Finch](https://en.wikipedia.org/wiki/What_Remains_of_Edith_Finch)
- [Observation](https://en.wikipedia.org/wiki/Observation_(video_game))
- [The Last of Us Part II](https://en.wikipedia.org/wiki/The_Last_of_Us_Part_II) <SideNote>Admittedly very violent, but not in a meaningless way.</SideNote>

The above avoid simplistic behaviour by employing a **tight narrative**, combined with exploration, mini-games and constrained scenarios.
Nevertheless, superficial character behaviour is the norm for video games.<SideNote width={450}>Sometimes simplistic behaviour is expected e.g. Arcade Games. On the other hand, even masterpieces like [Quake 1](https://en.wikipedia.org/wiki/Quake_1), [Fallout 2](https://en.wikipedia.org/wiki/Fallout_2), [GTA 2](https://en.wikipedia.org/wiki/GTA_2) and [Thief 2](https://en.wikipedia.org/wiki/Thief_2) suffer from simplistic behaviour.</SideNote>

<Carousel
  id="first-peek-video"
  height={650}
  mobileHeight={400}
  fullHeight={900}
  items={[{ video: 'first-peek', label: 'First peek' }]}
/>

We believe character behaviour is the main stumbling-block for video games. 
For example,

> the trend towards meaningless violence arises because violent behaviour is easier to implement.

> jarring cut-scenes reflect the inability of in-game behaviour to interactively tell the story.

Rather than avoiding the problem by tightening the narrative,
we'd prefer to develop more sophisticated behaviour.
But how?
We have a few core ideas.

{/* > A ghost attracts attention (curiosity).

> NPCs do things in multiple ways (choice).

> NPCs remember and forget (time sensitive).

<Aside title="clarify-sophisticated-behaviour">
  Technically these have all been done many times before.
  For example, an NPC with two attacks already makes choices.
  But these behaviours are rarely freely composable.
  > e.g. a polite NPC might let the Player through a door first (choice),
  and notice something while waiting (curiosity),
  which they later recollect (time sensitive).

  We are interested in combining behaviours,
  whilst maintaining the Player's awareness.
</Aside>

But how are we going to create more sophisticated behaviour? */}
{/* We have a few core ideas. */}

{/* some kinds of "sophisticated" character behaviour may be incompatible with a video game e.g. players replaying scenarios in "Last of Us" may want to repeatability */}

1. Create and combine character behaviours without trying to create a video game.
   
1. Develop differently:
    - Declarative rendering via HTML, CSS and [WAAPI](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Web_Animations_API_Concepts).
    - In-browser scripting via [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18) syntax interpreted as JavaScript.

1. Use openly available assets:
    - Robert Pearce's [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html) and Eric Smith's [PNG format](http://ericbsmith.no-ip.org/geomorphs/).
    - Robert Brook's [Top down men game asset character pack](https://www.gamedeveloperstudio.com/graphics/viewgraphic.php?page-name=Top-down-men-game-asset-character-pack&item=1r6d547z6f232v871n). <SideNote>Not free but only `$14.95` including [Spriter](https://brashmonkey.com/spriter-pro/) source files.</SideNote>

1. Use the [Traveller universe](https://en.wikipedia.org/wiki/Traveller_(role-playing_game)) as background context.<SideNote>The concept of _Starship Geomorph_ comes from Traveller.</SideNote>

Then we intend to approach the problem directly,
by creating and combining behaviours for their own sake.
However, this is a difficult thing to do: we risk creating something neither of **general interest** nor with much **entertainment value**.

<Carousel
  baseSrc="/assets/pics/first-peek/"
  height={550}
  mobileHeight={450}
  fullHeight={800}
  items={[
    { src: 'npcs-1.png', webp: true, label: 'A World (left) and a Terminal (right)' },
  ]}
/>

We tackle _general interest_ in a few ways.

- Our implementation uses _standard_ web development techniques
(relevant to a wide audience).
For example we use [CSS](https://en.wikipedia.org/wiki/CSS) and the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API) for rendering, rather than inner loops invoking [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame).

- Our approach to in-browser scripting stands on its own.
We provide an interactive shell interpreting POSIX syntax as JavaScript.<SideNote>Parsed using the wonderful [mvdan-sh](https://github.com/mvdan/sh/tree/master/_js).</SideNote>
This Command Line Interface ([CLI](https://en.wikipedia.org/wiki/Command-line_interface)) enriched with NPC-related shell functions gives our website its name.

- We consider character behaviour relevant to a vast number of video games.

But what about _entertainment value_?
If we're going to make more meaningful video games (via richer behaviour),
they'd better be more entertaining too.
Any additional depth must be seamlessly integrated into the experience.
For example:
- Sometimes deterministic behaviour is desirable to avoid frustrating the Player.
- Complex simulations are of little value if they are never witnessed or understood by the Player.

A _Player-centric approach_ will avoid these pitfalls.
But there is another important problem:
_although we don't want to create a video game,
we also don't want an abstract collection of behaviours_.
Thus we provide context on two levels: a setting (Traveller universe) and a narrative container (joining the behaviours together).
The latter is called "The Experiment". It has at least two interpretations...

{/* Finally, we must ensure our desire for generality does not produce a dry abstract approach. */}

{/* Entertainment will arise by interacting with our little fabricated worlds. */}
{/* We'll program Non-player Characters ([NPCs](https://en.wikipedia.org/wiki/Non-player_character)) and programming requires patience. */}

<Carousel
  baseSrc="/assets/pics/first-peek/"
  height={600}
  mobileHeight={450}
  fullHeight={800}
  items={[
    { src: 'npcs-2.png', webp: true, label: 'Each World provides a birdsye view.' },
    { src: 'npcs-3.png', webp: true, label: 'Each World is driven by one or more Terminals.' },
  ]}
/>

### Worlds, Players and Terminals

Behaviour arises relative to a _World_.
Defining a World amounts to choosing [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html) and connecting them together.
At present, we only support 5 geomorphs (Robert Pearce provided hundreds) constructed from about 80 [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html)<SideNote>Available in PNG format on [Eric Smith's site](http://ericbsmith.no-ip.org/geomorphs/).</SideNote> (Robert Pearce provided thousands).

<Carousel
  baseSrc="/assets/geomorph/"
  height={450}
  mobileHeight={350}
  fullHeight={800}
  items={[
    { src: 'g-101--multipurpose.map.png', webp: true, label: 'Geomorph 101 (Multipurpose)' },
    { src: 'g-102--research-deck.map.png', webp: true, label: 'Geomorph 102 (Research Deck)' },
    { src: 'g-301--bridge.map.png', webp: true, label: 'Geomorph 301 (Bridge)' },
    { src: 'g-302--xboat-repair-bay.map.png', webp: true, label: 'Geomorph 302 (Xboat Repair Bay)' },
    { src: 'g-303--passenger-deck.map.png', webp: true, label: 'Geomorph 303 (Passenger Deck)' },
  ]}
/>

The thin white rectangles are _doors_. The larger doors on the edges are called _hull doors_.
The geomorphs should be arranged so each hull door either (a) touches nothing else, (b) coincides with exactly one other hull door.
Then we "glue" geomorphs together at their hull doors -- exactly their original purpose.
Below we have combined `101`, `301`, and also `101`, `102`, `303`.

<Tabs
  id="world-map-only"
  initEnabled={false}
  height={[400, 500]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'map-only-1', props: {
          init: { y: 600, zoom: 0.3 },
          worldKey: 'map-only-1',
          gms: [
            { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
            { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
          ],
      }},
      { type: 'component', class: 'World', filepath: 'map-only-2', props: {
          init: { x: 600, y: 600, zoom: 0.3 },
          worldKey: 'map-only-2',
          gms: [
            { gmKey: 'g-101--multipurpose' },
            { gmKey: 'g-102--research-deck', transform: [1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-102--research-deck', transform: [-1, 0, 0, 1, 0, 0] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, 1, 0, -600] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, -1, 0, 600 + 1200] },
          ],
      }},
    ],
  ]}
/>

<Aside title="can-pan-zoom-tabs">
  In the maps above:
  - you can pan (_drag_).
  - you can zoom (_pinch_ or _scroll_).
  - you can drag their tabs around (or maximise them).<SideNote>Thanks to the wonderful tabs manager [flexlayout-react](https://www.npmjs.com/package/flexlayout-react).</SideNote>
</Aside>

In fact we have just seen two _Worlds_ i.e. [World.js](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/World.jsx "@new-tab") component instances.
The first map amounts to the following component instantiation:

```jsx
<World
  worldKey="map-only-1"
  gms={[
    { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
    { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
    { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
  ]}
/>
```

The `worldKey` identifies the World's API (more on that later),
whereas `gms` specifies the geomorphs and their layout.
But why do these worlds look like maps?
Answer: there is no _Player_ and thus no _Field Of View_.<SideNote>We already saw the Player-sensitive FOV (Field Of View) in the [video earlier](#first-peek-video).</SideNote>

So our World needs a Player.
This brings us to a very important ingredient: the `<Terminal>`.
Designing user interfaces is _hard_.
Insofar as textual user interfaces are concerned, we've gone the canonical route i.e. [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html).
Syntactically we provide an interactive shell.
Semantically we manipulate Javascript values and run async generators.

Let's see it action.
The Terminal's _profile_ explains itself step-by-step,
prompting the user to "tap to continue".

<Aside title="mobile-tty-touch-menu">
  Each `<Terminal>` has a side-menu: `<`,
  particularly helpful for mobile devices.
</Aside>

<Tabs
  id="tabs@world-1"
  initEnabled={false}
  height={[600, 600]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'world-1', props: {
        worldKey: 'world-1',
        init: { zoom: 0.5 , y: 600, ms: 0 },
        gms: [
          { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
          { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
          { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
        ],
      }},
    ],
    [
      { type: 'terminal', filepath: 'tty@world-1', env: {
        WORLD_KEY: 'world-1',
        PROFILE:
`source /etc/util-1
source /etc/game-1

awaitWorld

NOECHO=1 choice "${ansi.Reverse}${ansi.Bold}So far, this terminal's profile has defined shell functions and connected to world \\$WORLD_KEY.${ansi.Reset} tap to [continue](-)"

spawn rob '{x: -90, y: 1075}'
npc set-player rob
view 1 '{x: -90, y: 1075}' 1.6

NOECHO=1 choice "${ansi.Reverse}${ansi.Bold}Next we've spawned an npc \\"rob\\", set them as the Player and pan-zoomed them into view.${ansi.Reset} tap to [continue](-)"

npc map hide
goLoop rob &
doLoop rob &
lookLoop rob &

NOECHO=1 echo "${ansi.Reverse}${ansi.Bold}Finally we have faded the map and set up the Player's controls."
NOECHO=1 echo
NOECHO=1 echo "ℹ️  tap navmesh (to ${ansi.Bold}move${ansi.BoldReset}), tap doors/icons (to ${ansi.Bold}do things${ansi.BoldReset}), tap elsewhere (to ${ansi.Bold}look${ansi.BoldReset})."
`
      }},
    ],
  ]}
/>

<Aside title="do-all-the-things">

  Things to try with the World and Terminal above:
  - Open a door.
  - Lie in a bed.
  - Sit on the bog.
  - Reset everything (<Icon icon="refresh" small inline />).
  - Pause everything (<Icon icon="cross-circle" small inline />).
  - Follow the Player by running <InlineCode copy>track rob</InlineCode>.
  - Stop following via Ctrl-C ("kill" on mobile).
  - List background processes <InlineCode copy>ps</InlineCode>.
  - Kill background processes <InlineCode copy>kill 8 18 26</InlineCode>.<SideNote>You can also pause/resume processes via `--STOP` and `--CONT`</SideNote>
  - List shell functions <InlineCode copy>declare -F</InlineCode>.
  - Inspect a shell script <InlineCode copy>/etc/util-1</InlineCode>.

  <Carousel
    id="do-all-the-things-video"
    height={550}
    mobileHeight={400}
    fullHeight={900}
    items={[{ video: 'do-all-the-things', label: 'Doing all the things' }]}
  />

</Aside>

### Fabricating a behaviour

We're finally ready to create an NPC behaviour.
We need a _World_, the _Player_ and an additional character i.e. _NPC_.<SideNote>Recall NPC stands for Non-Player Character.</SideNote>

🚧
{/* Check out the profile of the terminal below. */}

<Tabs
  id="tabs@world-1+"
  initEnabled={false}
  height={[600, 600]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'world-1+', props: {
        worldKey: 'world-1+',
        init: { zoom: 0.5 , y: 600, ms: 0 },
        gms: [
          { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
          { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
          { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
        ],
      }},
    ],
    [
      { type: 'terminal', filepath: 'tty@world-1+', env: {
        WORLD_KEY: 'world-1+',
        PROFILE:
`source /etc/util-1
source /etc/game-1

awaitWorld

NOECHO=1 choice "${ansi.Reverse}${ansi.Bold}So far, this terminal's profile has defined shell functions and connected to world \\$WORLD_KEY.${ansi.Reset} tap to [continue](-)"

spawn rob '{x: -90, y: 1075}'
npc set-player rob
view 1 '{x: -90, y: 1075}' 1.6

NOECHO=1 choice "${ansi.Reverse}${ansi.Bold}Next we've spawned an npc \\"rob\\", set them as the Player and pan-zoomed them into view.${ansi.Reset} tap to [continue](-)"

npc map hide
goLoop rob &
doLoop rob &
lookLoop rob &

NOECHO=1 echo "${ansi.Reverse}${ansi.Bold}Finally we have faded the map and set up the Player's controls."
NOECHO=1 echo
NOECHO=1 echo "ℹ️  tap navmesh (to ${ansi.Bold}move${ansi.BoldReset}), tap nearby doors/icons (to ${ansi.Bold}do things${ansi.BoldReset}), and tap elsewhere (to ${ansi.Bold}look${ansi.BoldReset})."
`
      }},
    ],
  ]}
/>


{/* ```jsx
// internals and return value simplified
export default function NPC({ api, npcKey }) {
  const state = useStateRef(() => {...}); // `api.npcs.npc[npcKey]`

  return (
    <div
      ref={state.npcRef}
      className={`npc ${state.anim.spriteSheet} ...`}
    >
      <div className={`body webp ${state.key}`} />
      <div className="interact-circle" />
      <div className="bounds-circle" />
      <div
        className="head-circle"
        data-meta={JSON.stringify({ npc: true, ui: true, npcKey: state.key })}
      />
    </div>
  );
}
```

Each of the above divs has an associated purpose:
- `div.npc`: translation.
- `div.body`: rotation, opacity, spritesheet.
- `div.interact-circle`: interact radius.
- `div.bounds-circle`: collision radius.
- `div.head-circle`: clickable. */}


{/* Each World instantiates subcomponents including [`<NPCs>`](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/NPCs.jsx).
The latter has state `api.npcs` and instantiates each NPC. */}

{/* 🚧 shell command (or _command_)

🚧 game command: command using some World API

🚧 npc behaviour (or _behaviour_): game command using some World npcs API */}

{/* NPC behaviour may be _simulated_ i.e. task-driven imitations of human behaviour. NPC behaviour may be _fabricated_ i.e. specifically constructed in response to the Player's actions. */}
{/* For example, if the Player enters a particular room we could spawn enemies (fabrication) which are instructed to chase after the Player (simulation). */}

{/* By this we mean an interactive [Command Line Interface](https://en.wikipedia.org/wiki/Command-line_interface) running in the browser.
Graphically it amounts to [Xterm.js](https://github.com/xtermjs/xterm.js#readme).<SideNote>Keypresses are handled by our own analog of [Readline](https://en.wikipedia.org/wiki/GNU_Readline).</SideNote>
Programmatically it interprets POSIX shell syntax as JavaScript and executes it.<SideNote>We parse shell syntax using the wonderful [mvdan-sh](https://www.npmjs.com/package/mvdan-sh).</SideNote>
Supported syntax includes shell pipelines, shell functions and background processes.*/}

{/* <Aside title="interpret-js">

But how is shell syntax interpreted as JavaScript?

> Consider our shell function `call`.<br/>
> Given a textual description of a JavaScript function and its arguments, it creates the JavaScript function and its arguments, and finally invokes this function with these arguments.

As another example, the shell builtin `run` creates and iterates a JavaScript [AsyncGenerator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function*).
The shell functions `call`, `map`, `range` and `split` (above) are all defined in terms of `run`.

</Aside> */}

{/* There are two basic ways to create browser-based video games:
[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) and
[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS).
The `<canvas>` amounts to an image we can manipulate via JavaScript.
We can fill shapes, put pixels, or even [render 3D worlds](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) at 60 frames per second.
When someone says _HTML5 game_, the underlying tech is almost always the `<canvas>` element.
On the other hand, non-gaming websites rarely use it.

The cornerstones of the World Wide Web are HTML, CSS and JavaScript.
A typical website amounts to a deep [DOM-tree](https://en.wikipedia.org/wiki/Document_Object_Model) initially induced by HTML, brought to life _visually_ via CSS <SideNote>e.g. `<link>` and `<style>` nodes</SideNote> and _interactively_ via JavaScript<SideNote>Technically, JS permits arbitrary DOM mutation.</SideNote>.
Concerning CSS, web browsers interpret it very efficiently.
Its declarative approach avoids re-inventing the wheel via heavy-duty JavaScript.<SideNote>Although HTMLCanvas is performant via [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API), the latter is a low-level API.</SideNote>
Finally, CSS permits _rich interactive debugging_.
That is, one may directly mutate the DOM-tree in a browser devtool,
whereas debugging `<canvas>` amounts to setting breakpoints inside JavaScript code. */}

{/* We want to program NPCs, producing a catalogue of interesting behaviours.
We are particularly interested in studying how they can be composed in response to the Player's actions.
However, NPC behaviours need to be studied at the right level of abstraction.
We are not trying to create _middleware_.
We do not want to create a generic Game AI system, upon which "real games" can be scaffolded.
_Why?_
Because NPC behaviour is highly contextual.
It is usually brought to life via assets representing a specific situation: suitable background scenery and animations of particular denizens.

We definitely need this _spice_ i.e. assets and animations which bring our NPCs to life.
> Thankfully we can use [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html "@new-tab") by Robert Pearce,
> a large number of aerial-view assets representing Starships, Space-stations, Space-colonies etc.
*/}

{/* ### Changelog

| date | change |
| --- | ----------- |
| 2022-??-?? | created [Home page](/) |
|  | created [About](/about) |
|  | created preview [Setup](/intro/setup) |
|  | created preview [JavaScript CLI](/intro/js-cli) |
|  | created preview [Game AI CLI](/intro/ai-cli) | */}
