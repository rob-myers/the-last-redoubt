---
key: index
date: 2023-06-01
info: Home page
# ⛔️ GraphQL error avoided if ≥ 1 instance of field
giscusTerm: /home
label: home
navGroup: null
next: intro/
path: /
prev: null
tags:
  - video games
  - behaviour
  - web dev
  - cli
  - traveller
---

import Carousel from "components/page/Carousel";
import Icon, { RoadWorksIcon } from "components/page/Icon";
import InlineCode from "components/page/InlineCode";
import SideNote from "components/page/SideNote";
import Tabs from "components/page/Tabs";
import Def from "components/page/Def";
import Aside from "components/page/Aside";
import { ansi } from "projects/sh/util";

## home

### Introduction

We want to make video games more meaningful.
That is the objective of this website.
They have become synonymous with meaningless violence, bad storytelling and **simplistic character behaviour** (NPC as a [meme](https://en.wikipedia.org/wiki/NPC_(meme))).
On the other hand, there are plenty of exceptions out there.
Recent examples include:
- [What Remains of Edith Finch](https://en.wikipedia.org/wiki/What_Remains_of_Edith_Finch)
- [Observation](https://en.wikipedia.org/wiki/Observation_(video_game))
- [The Last of Us Part II](https://en.wikipedia.org/wiki/The_Last_of_Us_Part_II) <SideNote>Admittedly very violent, but not in a meaningless way.</SideNote>

These games avoid simplistic character behaviour by employing a **tight narrative**, combined with exploration, mini-games and constrained scenarios.
Nevertheless, simplistic character behaviour is the norm.

<Carousel
  id="first-peek-video"
  baseSrc="/assets/pics/first-peek/"
  height={550}
  mobileHeight={400}
  fullHeight={900}
  items={[{ video: 'first-peek', label: 'First peek' }]}
/>

Concerning simplistic behaviour,
both meaningless violence and bad storytelling may actually be _side-effects_. If the behaviour was more sophisticated it could help tell the story,
and the game-mechanic needn't revolve around violence.
Rather than avoiding the problem by tightening the narrative,
we'd prefer to develop more sophisticated behaviour.
But how?

We have a few core ideas.

{/* some kinds of "sophisticated" character behaviour may be incompatible with a video game e.g. players replaying scenarios in "Last of Us" may want to repeatability */}

1. Create and combine character behaviours without trying to create a video game.
   
1. Develop differently:
    - Declarative rendering via HTML, CSS and [WAAPI](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Web_Animations_API_Concepts).
    - In-browser scripting via [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18) syntax interpreted as JavaScript.

1. Use openly available assets:
    - Robert Pearce's [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html) and Eric Smith's [PNG format](http://ericbsmith.no-ip.org/geomorphs/).
    - Robert Brook's [Top down men game asset character pack](https://www.gamedeveloperstudio.com/graphics/viewgraphic.php?page-name=Top-down-men-game-asset-character-pack&item=1r6d547z6f232v871n). <SideNote>Not free but only `$14.95` including [Spriter](https://brashmonkey.com/spriter-pro/) source files.</SideNote>

1. Work within the [Traveller universe](https://en.wikipedia.org/wiki/Traveller_(role-playing_game)).<SideNote>The concept of _Starship Geomorph_ comes from Traveller.</SideNote>

Then we intend to approach the problem directly,
by creating and combining behaviours purely for their own sake.
However, this is a difficult thing to do: we risk creating something neither of **general interest** nor with much **entertainment value**.

<Carousel
  baseSrc="/assets/pics/first-peek/"
  height={600}
  mobileHeight={450}
  fullHeight={800}
  items={[
    { src: 'npcs-1.png', webp: true, label: 'A World (left) and a Terminal (right)' },
  ]}
/>

We tackle _general interest_ in a few ways.

- Our implementation uses _standard_ web development techniques,
relevant to a wide audience.
For example we use [CSS](https://en.wikipedia.org/wiki/CSS) and the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API) for rendering, rather than inner loops invoking [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame).

- Our approach to in-browser scripting has many applications.
We provide an interactive shell interpreting POSIX syntax as JavaScript.<SideNote>Parsed using the wonderful [mvdan-sh](https://github.com/mvdan/sh/tree/master/_js).</SideNote>
The resulting Command Line Interface ([CLI](https://en.wikipedia.org/wiki/Command-line_interface)) enriched with NPC-related shell functions gives our website its name.

- We consider character behaviour relevant to a vast number of video games.

But what about _entertainment value_?
If we're going to make video games more meaningful,
they had better be more entertaining too.
Any additional depth must be seamlessly integrated into the experience.
For example:
- Sometimes deterministic behaviour is desirable to avoid frustrating the Player.
- Complex simulations are of little value if they are never witnessed or understood by the Player.

Then a _Player-centric approach_ is required in order to avoid these pitfalls.
Finally, we must ensure our desire for generality does not produce a dry abstract approach.

{/* Entertainment will arise by interacting with our little fabricated worlds. */}
{/* We'll program Non-player Characters ([NPCs](https://en.wikipedia.org/wiki/Non-player_character)) and programming requires patience. */}

<Carousel
  baseSrc="/assets/pics/first-peek/"
  height={600}
  mobileHeight={450}
  fullHeight={800}
  items={[
    { src: 'npcs-2.png', webp: true, label: 'Each World provides a birdsye view.' },
    { src: 'npcs-3.png', webp: true, label: 'Each World is driven by one or more Terminals.' },
  ]}
/>

### Fabricating a behaviour

Behaviour arises relative to a _World_.
Defining a World amounts to choosing [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html) and connecting them together.
At present, we only support 5 geomorphs (Robert Pearce provided hundreds) constructed from about 80 [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html)<SideNote>Available in PNG format on [Eric Smith's site](http://ericbsmith.no-ip.org/geomorphs/).</SideNote> (Robert Pearce provided thousands).

<Carousel
  baseSrc="/assets/geomorph/"
  height={450}
  mobileHeight={350}
  fullHeight={800}
  items={[
    { src: 'g-101--multipurpose.map.png', webp: true, label: 'Geomorph 101 (Multipurpose)' },
    { src: 'g-102--research-deck.map.png', webp: true, label: 'Geomorph 102 (Research Deck)' },
    { src: 'g-301--bridge.map.png', webp: true, label: 'Geomorph 301 (Bridge)' },
    { src: 'g-302--xboat-repair-bay.map.png', webp: true, label: 'Geomorph 302 (Xboat Repair Bay)' },
    { src: 'g-303--passenger-deck.map.png', webp: true, label: 'Geomorph 303 (Passenger Deck)' },
  ]}
/>

The thin white rectangles are _doors_. The larger doors on the edges are called _hull doors_.
The geomorphs should be transformed so each hull door either (a) touches nothing else, (b) coincides with exactly one other hull door.
Intuitively we "glue" geomorphs together at their hull doors -- exactly their original purpose.
Below we have combined `101`, `301`, and also `101`, `102`, `303`.

<Tabs
  id="world-map-only"
  initEnabled={false}
  height={[400, 500]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'world-map-1', props: {
          init: { y: 600, zoom: 0.3 },
          worldKey: 'world-map-1',
          gms: [
            { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
            { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
          ],
      }},
      { type: 'component', class: 'World', filepath: 'world-map-2', props: {
          init: { x: 600, y: 600, zoom: 0.3 },
          worldKey: 'world-map-2',
          gms: [
            { gmKey: 'g-101--multipurpose' },
            { gmKey: 'g-102--research-deck', transform: [1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-102--research-deck', transform: [-1, 0, 0, 1, 0, 0] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, 1, 0, -600] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, -1, 0, 600 + 1200] },
          ],
      }},
    ],
  ]}
/>

<Aside title="can-pan-zoom-tabs">
  Concerning the maps above, you can:
  - pan (_drag_) them.
  - zoom (_pinch_ or _scroll_) them.
  - drag their tabs around, or maximise them.<SideNote>Thanks to the wonderful tabs manager [flexlayout-react](https://www.npmjs.com/package/flexlayout-react).</SideNote>
</Aside>

In fact we have just seen two _Worlds_ i.e. [World.js](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/World.jsx "@new-tab") component instances.
The first map amounts to the following component instantiation:

```jsx
<World
  worldKey="world-map-1"
  gms={[
    { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
    { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
    { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
  ]}
/>
```

`worldKey` uniquely identifies the World's API.
`gms` specifies the geomorphs and their layout, as outlined above.
Why do these worlds look like maps?
Because there is no _Player_ and consequently no _Field Of View_.<SideNote>We already saw the Player-sensitive FOV in the [video earlier](#first-peek-video).</SideNote>

So next we need a World with a Player.
This brings us to a very important ingredient: the `<Terminal>`.
Designing user interfaces is _hard_.
Insofar as textual interfaces are concerned, we've gone the canonical route i.e. POSIX.
Syntactically we provide an interactive shell.
Semantically we manipulate Javascript values and run async generators. 

🚧

<Tabs
  id="tabs@world-1"
  initEnabled={false}
  height={[600, 600]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'world-1', props: {
        worldKey: 'world-1',
        init: { zoom: 0.5 , y: 600, ms: 0 },
        gms: [
          { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
          { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
          { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
        ],
      }},
    ],
    [
      { type: 'terminal', filepath: 'tty@world-1', env: {
        WORLD_KEY: 'world-1',
        PROFILE:
`source /etc/util-1
source /etc/game-1

awaitWorld

NOECHO=1 echo "${ansi.Reverse}${ansi.Bold}So far this profile has loaded various shell functions and connected to the World.${ansi.Reset}"
NOECHO=1 choice 'tap to [continue](-)'

spawn bilem '{x:-89.8,y:1075.7}'
npc set-player bilem
view 1000 '{x:-89.8,y:1075.7}' 1.6

NOECHO=1 echo "${ansi.Reverse}${ansi.Bold}Next we've spawned an npc called \\"bilem\\", set them as the Player, and finally pan-zoomed them into view.${ansi.Reset}"
NOECHO=1 choice 'tap to [continue](-)'

npc map hide
goLoop bilem &
doLoop bilem &
lookLoop bilem &

NOECHO=1 echo "${ansi.Reverse}${ansi.Bold}Finally we hide the map and setup the Player. Tap navmesh (to move), nearby doors/icons (to do things), elsewhere (to look).${ansi.Reset}"
`
      }},
    ],
  ]}
/>

<Aside title="tips-and-tricks">

  Things to try with the World and Terminal above:
  - Sit in a chair.
  - Open a door.
  - Lie in a bed.
  - Reset everything (<Icon icon="refresh" small inline />).
  - Pause everything (<Icon icon="cross-circle" small inline />).
  - Follow the Player by running <InlineCode copy>track bilem</InlineCode>.
  - Stop following via Ctrl-C (💀 on mobile).
  - List background processes <InlineCode copy>ps</InlineCode>.
  - Kill background processes <InlineCode copy>kill 8 18 26</InlineCode>.<SideNote>You can also pause/resume processes via `--STOP` and `--CONT`</SideNote>

</Aside>


OLD BELOW (may move elsewhere)

{/* What actually _is_ a character behaviour?
Roughly speaking, it involves the Player observing or interacting with one or more NPCs.
We believe this is worth defining formally.
We need other concepts i.e. World, NPC, Player and Command.

<Def title="world">

  #### Definition: World
  
  A _World_ is a component instance [`<World>`](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/World.jsx "@new-tab").
  
  Its required props<SideNote>A.k.a. _inputs_, see [the component](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/World.jsx#:~:text=@typedef%20Props).</SideNote> are `worldKey` (string) and
  `gms` (objects `{gmKey, transform}`), specifying the geomorphs and where to put them.
  Its [state](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/World.jsx#:~:text=const%20state "@new-tab") is stored under `worldKey` in an application-wide [cache](https://tanstack.com/query/v4/docs/react/reference/QueryClient "@new-tab"). This external API is denoted `api`.

</Def>

At present, we support 5 geomorphs (Robert Pearce provided [hundreds](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html "@new-tab")) constructed from about 80 of his [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html "@new-tab")<SideNote>Available in PNG format on [Eric Smith's site](http://ericbsmith.no-ip.org/geomorphs/ "@new-tab").</SideNote>.

<Carousel
  baseSrc="/assets/geomorph/"
  height={450}
  mobileHeight={350}
  fullHeight={800}
  items={[
    { src: 'g-101--multipurpose.map.png', webp: true, label: 'Geomorph 101 (Multipurpose)' },
    { src: 'g-102--research-deck.map.png', webp: true, label: 'Geomorph 102 (Research Deck)' },
    { src: 'g-301--bridge.map.png', webp: true, label: 'Geomorph 301 (Bridge)' },
    { src: 'g-302--xboat-repair-bay.map.png', webp: true, label: 'Geomorph 302 (Xboat Repair Bay)' },
    { src: 'g-303--passenger-deck.map.png', webp: true, label: 'Geomorph 303 (Passenger Deck)' },
  ]}
/>

The thin white rectangles are _doors_. The larger doors on the edges are called _hull doors_.
The geomorphs should be transformed so each hull door either (a) touches nothing else, (b) coincides with exactly one other hull door.
Intuitively we "glue" geomorphs together at their hull doors -- exactly their original purpose.
Below we have combined `101`, `301`, and also `101`, `102`, `303`.

```jsx
<World
  worldKey="map-only-1"
  gms={[
    { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
    { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
    { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
  ]}
/>

<World
  worldKey="map-only-2"
  gms={[
    { gmKey: 'g-101--multipurpose' },
    { gmKey: 'g-102--research-deck', transform: [1, 0, 0, 1, 1200, 0] },
    { gmKey: 'g-102--research-deck', transform: [-1, 0, 0, 1, 0, 0] },
    { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, 1, 0, -600] },
    { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, -1, 0, 600 + 1200] },
  ]}
/>
```

<Tabs
  id="world-map-only"
  initEnabled={false}
  height={[400, 500]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'map-only-1', props: {
          init: { x: 600, y: 600, zoom: 0.3 },
          worldKey: 'map-only-1',
          gms: [
            { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
            { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
          ],
      }},
      { type: 'component', class: 'World', filepath: 'map-only-2', props: {
          init: { x: 600, y: 600, zoom: 0.3 },
          worldKey: 'map-only-2',
          gms: [
            { gmKey: 'g-101--multipurpose' },
            { gmKey: 'g-102--research-deck', transform: [1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-102--research-deck', transform: [-1, 0, 0, 1, 0, 0] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, 1, 0, -600] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, -1, 0, 600 + 1200] },
          ],
      }},
    ],
  ]}
/>

The Worlds above lack NPCs e.g. there is no Player.
Then there is no representation of the Player's _sensory awareness_, and the World amounts to a static pan/zoomable map.

<Def title="npc-and-player">

  #### Definitions: NPC, Player
  
  An _NPC_ is a component instance [`<NPC>`](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/NPC.jsx "@new-tab").
  
  Its props are `api` and `npcKey` (string) i.e. the NPC's _key_.
  Its state is stored at `api.npcs.npc[npcKey]` and created by
  [create-npc.js](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/create-npc.js "@new-tab").
  Finally, an NPC is the _Player_ if it has key `api.npcs.playerKey`.

</Def>

Each World is an instance of a React function component, as is each NPC.
We postpone the internals of World to a future blog post.
However, it will help to look at NPC right now. */}

{/* ```jsx
// internals and return value simplified
export default function NPC({ api, npcKey }) {
  const state = useStateRef(() => {...}); // `api.npcs.npc[npcKey]`

  return (
    <div
      ref={state.npcRef}
      className={`npc ${state.anim.spriteSheet} ...`}
    >
      <div className={`body webp ${state.key}`} />
      <div className="interact-circle" />
      <div className="bounds-circle" />
      <div
        className="head-circle"
        data-meta={JSON.stringify({ npc: true, ui: true, npcKey: state.key })}
      />
    </div>
  );
}
```

Each of the above divs has an associated purpose:
- `div.npc`: translation.
- `div.body`: rotation, opacity, spritesheet.
- `div.interact-circle`: interact radius.
- `div.bounds-circle`: collision radius.
- `div.head-circle`: clickable. */}


{/* Each World instantiates subcomponents including [`<NPCs>`](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/NPCs.jsx).
The latter has state `api.npcs` and instantiates each NPC. */}

{/* How can we spawn NPCs into a World?
Although there is a JavaScript function `api.npcs.spawn` we'd rather not invoke it directly.
JavaScript is not designed to be run interactively. */}

{/* In order to spawn NPCs into a World we use a Command Line Interface (CLI). */}

🚧 shell command (or _command_)

🚧 game command: command using some World API

🚧 npc behaviour (or _behaviour_): game command using some World npcs API

{/* We'll **specify behaviour** using the syntax of an interactive programming language.
We'll **execute behaviour** by running (possibly many) programs in parallel.
But what about **(2)** above?
Why should the **implementation details** of our system be of general interest?
Answering this requires some background.

_Game AI_ builds control systems for Non-Player Characters (NPCs) in video games.
Scratching beneath the surface reveals a highly fragmented subject.
Online demos involving [navmeshes](https://www.babylonjs-playground.com/#0DQBXD#42 "@new-tab") and [steering behaviour](https://davenewt.github.io/steering-behaviours/ "@new-tab") exist, but these are ingredients, rather than the rich experiences we seek.
Why does Game AI only seem to exist within the context of a video game?

> Here's a possible reason:
>
> Assets and animations relative to a particular setting are needed to make Game AI meaningful.
In making these choices and constructing the respective assets, one moves away from a general AI system and towards making a video game.

*/}

{/* NPC behaviour may be _simulated_ i.e. task-driven imitations of human behaviour. NPC behaviour may be _fabricated_ i.e. specifically constructed in response to the Player's actions. */}
{/* For example, if the Player enters a particular room we could spawn enemies (fabrication) which are instructed to chase after the Player (simulation). */}

{/* Video games almost always need Game AI e.g. control systems for entities not under control of the Player. */}

{/* This blog is about programming Non-Player Characters (aka [NPCs](https://en.wikipedia.org/wiki/Non-player_character "@new-tab")).
An NPC is a character in a video game e.g. a human, alien, robot or animal.
They are not controlled by the Player.
Sometimes video games run a simulation involving individual NPCs.
Sometimes they fabricate NPC behaviour in response to the Player's actions.
My personal interest began with the ZX Spectrum in the late 1980s.
In those days anything seemed possible.
Nowadays, NPC has even become [an insult](https://en.wikipedia.org/wiki/NPC_(meme)). */}

{/* <Aside title="screenshots">

  _A World and a Terminal_ (1st slide above) depicts a [Tabs component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/components/page/Tabs.tsx#:~:text=function%20Tabs "@new-tab") with five tabs.
  Two of the tabs are visible.
  The left tab is an instance of a [World component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/projects/world/World.jsx#:~:text=export%20default-,function%20World,-(props) "@new-tab") and
  the right tab instantiates a [Terminal component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/components/sh/Terminal.tsx#:~:text=function%20Terminal "@new-tab").
  The `World` shows an NPC from a birdseye perspective.
  The other images show the `Tabs`, `World` and `Terminal` in other states.<SideNote width={500}>Some commands shown in the terminals are out-of-date. We now run `npc config debug` to toggle debug mode, rather than `DEBUG=1; npc config`</SideNote>

</Aside> */}

{/* By this we mean an interactive [Command Line Interface](https://en.wikipedia.org/wiki/Command-line_interface) running in the browser.
Graphically it amounts to [Xterm.js](https://github.com/xtermjs/xterm.js#readme).<SideNote>Keypresses are handled by our own analog of [Readline](https://en.wikipedia.org/wiki/GNU_Readline).</SideNote>
Programmatically it interprets POSIX shell syntax as JavaScript and executes it.<SideNote>We parse shell syntax using the wonderful [mvdan-sh](https://www.npmjs.com/package/mvdan-sh).</SideNote>
Supported syntax includes shell pipelines, shell functions and background processes.
Let's see it in action:

As mentioned in the video, every shell session begins by running the script at `/home/PROFILE`.
In the above session this absolute path resolves to a string:

```bash
source /etc/util-1
source /etc/game-1

awaitWorld
spawn andros '{"x":185,"y":390}'
npc set-player andros

# camera follows andros
track andros &
# click navmesh to move
goLoop andros &
# click outside navmesh to look
lookLoop andros &

npc config 'showIds debug'
```

Consider the first line of the newline-delimited string above.
Our shell builtin `source`<SideNote width={340}>`source` behaves like the [Bash builtin](https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-source), a synonym for a [Bourne shell builtin](https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#index-_002e).</SideNote> will run the script at `/etc/util-1`<SideNote width={360}>`/etc/util-1` resolves to a string defining various shell functions e.g. [`range`](https://github.com/rob-myers/the-last-redoubt/blob/master/src/projects/sh/scripts.ts#:~:text=%7B-,range%3A%20%60%7B "@new-tab")</SideNote>.
The video goes through the rest of this profile, explaining the various commands and their connection to the `World`. */}

{/* (a) list available shell functions, (b) inspect their definitions, and (c) chain them together using shell pipelines. */}

{/* <Aside title="interpret-js">

But how is shell syntax interpreted as JavaScript?

> Consider our shell function `call`.<br/>
> Given a textual description of a JavaScript function and its arguments, it creates the JavaScript function and its arguments, and finally invokes this function with these arguments.

As another example, the shell builtin `run` creates and iterates a JavaScript [AsyncGenerator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function*).
The shell functions `call`, `map`, `range` and `split` (above) are all defined in terms of `run`.

</Aside> */}

{/* There are two basic ways to create browser-based video games:
[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) and
[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS).
The `<canvas>` amounts to an image we can manipulate via JavaScript.
We can fill shapes, put pixels, or even [render 3D worlds](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) at 60 frames per second.
When someone says _HTML5 game_, the underlying tech is almost always the `<canvas>` element.
On the other hand, non-gaming websites rarely use it.

The cornerstones of the World Wide Web are HTML, CSS and JavaScript.
A typical website amounts to a deep [DOM-tree](https://en.wikipedia.org/wiki/Document_Object_Model) initially induced by HTML, brought to life _visually_ via CSS <SideNote>e.g. `<link>` and `<style>` nodes</SideNote> and _interactively_ via JavaScript<SideNote>Technically, JS permits arbitrary DOM mutation.</SideNote>.
Concerning CSS, web browsers interpret it very efficiently.
Its declarative approach avoids re-inventing the wheel via heavy-duty JavaScript.<SideNote>Although HTMLCanvas is performant via [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API), the latter is a low-level API.</SideNote>
Finally, CSS permits _rich interactive debugging_.
That is, one may directly mutate the DOM-tree in a browser devtool,
whereas debugging `<canvas>` amounts to setting breakpoints inside JavaScript code. */}

{/* Writing meaningfully about NPC behaviour will require _many_ flexible interactive demos.
So, we're going to have to write a lot of software,
and we're going to have to do it in a particularly clear manner.
Importantly:

- An in-browser CLI permits:
  > writing, running and managing this software _explicitly_.

- CSS-based rendering provides:
  > performant rendering and particularly rich debugging via a browser devtool.

POSIX-based CLIs are heavily used in e.g. home computing, development environments and cloud computing (infrastructure as a service).
CSS plays a crucial role in personal websites, rich web applications, and [desktop applications](https://www.electronjs.org/) like [VSCode](https://en.wikipedia.org/wiki/Visual_Studio_Code).
Composing these two technologies avoids many UI decisions, for which there is no correct answer. */}


{/* We want to program NPCs, producing a catalogue of interesting behaviours.
We are particularly interested in studying how they can be composed in response to the Player's actions.
However, NPC behaviours need to be studied at the right level of abstraction.
We are not trying to create _middleware_.
We do not want to create a generic Game AI system, upon which "real games" can be scaffolded.
_Why?_
Because NPC behaviour is highly contextual.
It is usually brought to life via assets representing a specific situation: suitable background scenery and animations of particular denizens.

We definitely need this _spice_ i.e. assets and animations which bring our NPCs to life.
> Thankfully we can use [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html "@new-tab") by Robert Pearce,
> a large number of aerial-view assets representing Starships, Space-stations, Space-colonies etc.

<Aside title="geomorph">

A _geomorph_ is a rectangular section of a Starship (or Space-station etc.) connectable to others much like Lego.
Each geomorph amounts to a layout of many different rooms of particular types e.g. staterooms (bedrooms), offices, freshers (bathrooms and toilets), labs, infirmaries, lounges etc.

<Carousel
  baseSrc="/assets/geomorph/"
  height={350}
  mobileHeight={300}
  fullHeight={800}
  invert
  items={[
    { src: 'g-301--bridge.map.png', label: 'Geomorph 301 (Bridge)' },
    { src: 'g-302--xboat-repair-bay.map.png', label: 'Geomorph 302 (Xboat Repair Bay)' },
    { src: 'g-303--passenger-deck.map.png', label: 'Geomorph 303 (Passenger Deck)' },
    { src: 'g-101--multipurpose.map.png', label: 'Geomorph 101 (Multipurpose)' },
    { src: 'g-102--research-deck.map.png', label: 'Geomorph 102 (Research Deck)' },
  ]}
/>

Above we have recreated some of Robert Pearce's geomorphs using his [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html "@new-tab").

</Aside>


🚧 Starship Geomorphs provides assets, but what about _character animations_?
Well, the term "geomorph" actually comes from a pen-and-paper Role-playing Game called Traveller....
We use [Synfig](https://www.synfig.org/ "@new-tab") for character animation. */}


{/* 🚧 Please [read the introduction](/intro/). Initially we need a fair amount of exposition.
This reflects our initial work on the "game engine" before we started creating this site.
Partial exposition is indicated by <RoadWorksIcon bottom />. */}

{/* ### Demo */}

{/* 🚧 Move after cli-video? */}

{/* 🚧 Actions speak louder than words.
Click to navigate or interact (e.g. open doors).
You can drag/scroll/pinch to pan and zoom.
Try resetting (<Icon icon="refresh" small inline />), maximising a tab or all tabs (<Icon icon="expand" small inline />), and disabling (<Icon icon="cross-circle" small inline />).
Toggle debug circles by typing <InlineCode copy>npc config debug</InlineCode>. */}

{/* ### Changelog

| date | change |
| --- | ----------- |
| 2022-??-?? | created [Home page](/) |
|  | created [About](/about) |
|  | created preview [Setup](/intro/setup) |
|  | created preview [JavaScript CLI](/intro/js-cli) |
|  | created preview [Game AI CLI](/intro/ai-cli) | */}
