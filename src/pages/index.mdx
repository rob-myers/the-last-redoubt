---
key: index
date: 2022-12-25
info: Home page
# ‚õîÔ∏è GraphQL error avoided if ‚â• 1 instance of field
giscusTerm: /home
label: home
navGroup: null
next: intro/
path: /
prev: null
tags:
  - npcs
  - cli
  - web dev
  - traveller rpg
---

import Carousel from "components/page/Carousel";
import Icon, { RoadWorksIcon } from "components/page/Icon";
import InlineCode from "components/page/InlineCode";
import SideNote from "components/page/SideNote";
import Tabs from "components/page/Tabs";
import { profileLookup } from "projects/sh/scripts";

## Home page

### About

This blog is about programming Non-Player Characters ([NPCs](https://en.wikipedia.org/wiki/Non-player_character)).
An NPC is a character in a video game e.g. a human, alien, robot or animal.
They are not controlled by the Player.
In one approach the Game runs a simulation involving individual NPCs.
In another, it fabricates the Player's experience in response to the Player's actions.
My personal interest began with the ZX Spectrum in the late 1980s.
In those days anything seemed possible.
Nowadays, NPC has even become [an insult](https://en.wikipedia.org/wiki/NPC_(meme)).

We'll try not to comment on the current state of affairs of video games.
They have their own metrics of success.
We're going to study NPCs for their own sake.
But what distinguishes our approach?

1. Dedicated to programming NPCs.
1. Browser-based CLI for doing so.
1. CSS-based rendering and interactivity.<SideNote>We intentionally avoid JavaScript [game loops](https://gamedev.stackexchange.com/a/656).</SideNote>
1. Rich graphics via [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html "@new-tab").

Before things get a bit abstract, here are some screenshots:

<Carousel
  baseSrc="/assets/pics/home-carousel/"
  height={550}
  breakpoints={{
    300: {
      slidesPerView: 1,
    },
    700: {
      slidesPerView: 2,
    },
  }}
  items={[
    { src: 'pic-1.png', label: 'A World and a Terminal' },
    { src: 'pic-2.png', label: 'Movement and commands' },
    { src: 'pic-3.png', label: 'Another Terminal awaits another World' },
    { src: 'pic-4.png', label: 'Disabling Tabs pauses sessions' },
    { src: 'pic-5.png', label: 'Multiple Worlds and Terminals' },
    { src: 'pic-6.png', label: 'Can resize Tab and Tabset' },
    { src: 'pic-7.png', label: 'Widescreen view' },
    { src: 'pic-8.png', label: 'Pausing a process' },
    { src: 'pic-9.png', label: 'Reading some variables' },
    { src: 'pic-10.png', label: 'Mobile has Terminal UI' },
    { src: 'pic-11.png', label: 'Piping output into devtool' },
  ]}
/>
{/* Component ~ React Component */}

<Aside title="screenshots">

  _A World and a Terminal_ (1st slide above) depicts a [Tabs component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/components/page/Tabs.tsx#:~:text=function%20Tabs "@new-tab") with five tabs.
  Two of the tabs are visible.
  The left tab is an instance of a [World component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/projects/world/World.jsx#:~:text=export%20default-,function%20World,-(props) "@new-tab") and
  the right tab instantiates a [Terminal component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/components/sh/Terminal.tsx#:~:text=function%20Terminal "@new-tab").
  The `World` shows an NPC from a birdseye perspective.
  The commands in the `Terminal` indicate this is Andros and he is actually the Player.
  The other images show the `Tabs`, `World` and `Terminal` in other states.<SideNote width={500}>Some commands shown in the terminals are out-of-date. In particular we now `npc config debug` to toggle debug mode, rather than `DEBUG=1; npc config`</SideNote>

</Aside>

Recall the second distinguishing point above:

> Browser-based CLI for doing so.

By this we mean an interactive [Command Line Interface](https://en.wikipedia.org/wiki/Command-line_interface) running in the browser.
Graphically it amounts to [Xterm.js](https://github.com/xtermjs/xterm.js#readme).<SideNote>Keypresses are handled by our own analog of [Readline](https://en.wikipedia.org/wiki/GNU_Readline).</SideNote>
Programmatically it interprets POSIX shell syntax as JavaScript and executes it.<SideNote>We parse shell syntax using the wonderful [mvdan-sh](https://www.npmjs.com/package/mvdan-sh).</SideNote>
Supported syntax includes shell pipelines, shell functions and background processes.
Let's see it in action:

<Carousel
  height={600}
  items={[{ video: 'cli-demo-1', label: 'First CLI Demo' }]}
/>

üöß redo video

As mentioned in the video, every shell session begins by running the script at `/home/PROFILE`.
In this particular session the absolute path resolves to a string:

```bash
source /etc/util-1
source /etc/game-1
awaitWorld
spawn andros '{"x":185,"y":390}'
npc set-player andros

# camera follows andros
track andros &
# click navmesh to move
goLoop andros &
# click outside navmesh to look
lookLoop andros &

npc config showIds
npc config showLabels
npc config debug
```

Consider the first line of the newline-delimited string above.
Our shell builtin `source`<SideNote width={340}>`source` behaves like the [Bash builtin](https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-source), a synonym for a [Bourne shell builtin](https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#index-_002e).</SideNote> will run the script at `/etc/util-1`<SideNote width={360}>`/etc/util-1` resolves to a newline-delimted string defining various shell functions e.g. [`range`](https://github.com/rob-myers/the-last-redoubt/blob/master/src/projects/sh/scripts.ts#:~:text=%7B-,range%3A%20%60%7B "@new-tab")</SideNote>.
The video goes through the rest of this profile, explaining the various commands and their connection to the `World`.

{/* (a) list available shell functions, (b) inspect their definitions, and (c) chain them together using shell pipelines. */}

<Aside title="interpret-js">

But how is shell syntax interpreted as JavaScript?

> Consider our shell function `call`.<br/>
> Given a textual description of a JavaScript function and its arguments, it creates the JavaScript function and its arguments, and finally invokes this function with these arguments.

As another example, the shell builtin `run` creates and iterates a JavaScript [AsyncGenerator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function*).
The shell functions `call`, `map`, `range` and `split` (above) are all defined in terms of `run`.

</Aside>

Recall our third distinguishing point:

> CSS-based rendering and interactivity.

There are two fundamental ways to create browser-based video games:
[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) and
[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS).
The `<canvas>` amounts to an image one can manipulate using JavaScript.
We can fill shapes, put pixels, or even [render 3D worlds](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) at 60 frames per second.
When someone says _HTML5 game_, the underlying tech is almost always the `<canvas>` element.
On the other hand, non-gaming websites rarely use it.

The cornerstones of the World Wide Web are HTML, CSS and JavaScript.
A typical website amounts to a deep [DOM-tree](https://en.wikipedia.org/wiki/Document_Object_Model) initially induced by HTML, brought to life _visually_ via CSS <SideNote>e.g. `<link>` and `<style>` nodes</SideNote> and _interactively_ via JavaScript<SideNote>Technically, JS permits arbitrary DOM mutation.</SideNote>.
Concerning CSS, web browsers interpret it very efficiently.
Its declarative approach avoids re-inventing the wheel via heavy-duty JavaScript.<SideNote>Although HTMLCanvas is performant via [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API), the latter is a low-level API.</SideNote>
Finally, CSS permits _rich interactive debugging_.
That is, one may directly mutate the DOM-tree in a browser devtool,
whereas debugging `<canvas>` amounts to setting breakpoints inside JavaScript code.

{/* CSS vs HTMLCanvas i.e. in our approach we can use Chrome devtool
Asymmetry of HTML and JavaScript DOM mutation
Analogy with Web vs App
Want to use Browser Devtool: canonical interface, like CLI */}

üöß browser devtool video

Now, writing meaningfully about NPC behaviour will require _many_ flexible interactive demos.
So, we're going to have to write a lot of software,
and we're going to have to do it in a particularly clear manner.
Importantly:

- An in-browser CLI permits:
  > writing, running and managing this software _explicitly_.

- CSS-based rendering permits:
  > performant rendering with particularly rich debugging via a browser devtool.


CLIs and CSS are used heavily in a vast number of disparate domains.
For example: development environments, infrastructure as a service, personal websites, rich web applications, and [desktop applications](https://www.electronjs.org/) like VSCode.
Aligning ourselves to these technologies will help us to ... üöß

üöß Starship geomorphs


{/* üöß Please [read the introduction](/intro/). Initially we need a fair amount of exposition.
This reflects our initial work on the "game engine" before we started creating this site.
Partial exposition is indicated by <RoadWorksIcon bottom />. */}


### Demo

üöß Actions speak louder than words.
Click to navigate or interact (e.g. open doors).
You can drag/scroll/pinch to pan and zoom.
Try resetting (<Icon icon="refresh" small inline />), maximising a tab or all tabs (<Icon icon="expand" small inline />), and disabling (<Icon icon="cross-circle" small inline />).
Toggle debug circles by typing <InlineCode copy>npc config debug</InlineCode>.

<Tabs
  id="demo-tabs"
  initEnabled={false}
  height={600}
  persistLayout
  initHorizontal
  tabs={[
    [
      { type: 'component', filepath: 'world-demo-1' },
    ],
    [
      { type: 'terminal', filepath: 'demo-1@test', env: { WORLD_KEY: 'world-demo-1', PROFILE: profileLookup['profile-1-a']() } },
    ],
  ]}
/>

### Changelog

| date | change |
| --- | ----------- |
| 2022-??-?? | created [Home page](/) |
|  | created [About](/about) |
|  | created preview [Setup](/intro/setup) |
|  | created preview [JavaScript CLI](/intro/js-cli) |
|  | created preview [Game AI CLI](/intro/ai-cli) |
