---
key: index
date: 2022-12-25
info: Home page
# ‚õîÔ∏è GraphQL error avoided if ‚â• 1 instance of field
giscusTerm: /home
label: home
navGroup: null
next: intro/
path: /
prev: null
tags:
  - web dev
  - game ai
  - traveller rpg
---

import Carousel from "components/page/Carousel";
import Icon, { RoadWorksIcon } from "components/page/Icon";
import InlineCode from "components/page/InlineCode";
import SideNote from "components/page/SideNote";
import Tabs from "components/page/Tabs";
import { profileLookup } from "projects/sh/scripts";

## Home page

### About

This blog is all about programming Non-Player Characters (NPCs).
They correspond to the dynamic part of video games,
excluding the Player and simple machines like doors and weapons.
My personal interest began with the ZX Spectrum in the late 1980s.
In those days anything seemed possible.
Nowadays, NPC has even become [an insult](https://en.wikipedia.org/wiki/NPC_(meme)).

We'll try to remain silent concerning the current state of affairs.
Video games have their own metrics of success.
We're going to study NPCs for their own sake.
But what distinguishes our approach?

1. Dedicated to programming NPCs.
1. Browser-based CLI for doing so.
1. CSS-based rendering and interactivity.<SideNote>We intentionally avoid JavaScript [game loops](https://gamedev.stackexchange.com/a/656).</SideNote>
1. Rich graphics via [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html "@new-tab").

Before things get a bit abstract, here are some screenshots:


<Carousel
  baseSrc="/assets/pics/home-carousel/"
  height={550}
  breakpoints={{
    300: {
      slidesPerView: 1,
    },
    700: {
      slidesPerView: 2,
    },
  }}
  items={[
    { src: 'pic-1.png', label: 'A World and a Terminal' },
    { src: 'pic-2.png', label: 'Movement and commands' },
    { src: 'pic-3.png', label: 'Another Terminal awaits another World' },
    { src: 'pic-4.png', label: 'Disabling Tabs pauses sessions' },
    { src: 'pic-5.png', label: 'Multiple Worlds and Terminals' },
    { src: 'pic-6.png', label: 'Can resize Tab and Tabset' },
    { src: 'pic-7.png', label: 'Widescreen view' },
    { src: 'pic-8.png', label: 'Pausing a process' },
    { src: 'pic-9.png', label: 'Reading some variables' },
    { src: 'pic-10.png', label: 'Mobile has Terminal UI' },
    { src: 'pic-11.png', label: 'Piping output into devtool' },
  ]}
/>

<!-- Component ~ React Component -->

<aside title="screenshots">

  _A World and a Terminal_ (1st slide above) depicts a [`Tabs` component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/components/page/Tabs.tsx#:~:text=function%20Tabs "@new-tab") with five tabs.
  Two of the tabs are visible.
  The left tab is an instance of a [`World` component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/projects/world/World.jsx#:~:text=export%20default-,function%20World,-(props) "@new-tab") and
  the right tab instantiates a [`Terminal` component](https://github.com/rob-myers/the-last-redoubt/blob/master/src/components/sh/Terminal.tsx#:~:text=function%20Terminal "@new-tab").
  The `World` shows an NPC from a birdseye perspective.
  The commands in the `Terminal` indicate this is Andros and he is actually the Player.
  The other images show the `Tabs`, `World` and `Terminal` in other states.

</aside>

> Browser-based CLI?

By this we mean an interactive Command Line Interface running in the browser.
Graphically it amounts to [Xterm.js](https://github.com/xtermjs/xterm.js#readme).<SideNote>Keypresses are handled by our own analog of [Readline](https://en.wikipedia.org/wiki/GNU_Readline).</SideNote>
Programmatically it interprets POSIX shell syntax as JavaScript and executes it.<SideNote>We parse shell syntax using the wonderful [mvdan-sh](https://www.npmjs.com/package/mvdan-sh).</SideNote>
Supported syntax includes shell pipelines, shell functions and background processes.
Let's see it in action:

<Carousel
  height={440}
  items={[{ video: 'cli-demo-1', label: 'First CLI Demo' }]}
/>

Every shell session starts by running the script at `/home/PROFILE`.
In the above session it is the string <InlineCode>source /etc/util-1</InlineCode> plus a trailing newline.
The builtin [source](https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html#index-source) runs the script at `/etc/util-1`,
which defines a bunch of shell functions e.g. `range`.
In the above video we (a) list available shell functions, (b) inspect their definitions, and (c) chain them together using shell pipelines.

<aside title="interpret-js">

But how is shell syntax interpreted as JavaScript?

Take the shell function `call` for example.
Given a textual description of a JavaScript function and its arguments, it creates the JavaScript function and its arguments, and finally invokes the function with the arguments.
Less obviously, the shell builtin `run` creates and iterates a JavaScript [AsyncGenerator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function*).
The shell functions `call`, `map`, `range` and `split` (above) are all defined in terms of `run`.

</aside>

> CSS-based rendering?

There are two basic ways to create browser-based video games:
[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) and
[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS).
The `<canvas>` amounts to an image one can manipulate using JavaScript.
We can fill shapes, put pixels, or even [render 3D worlds](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) at 60 fps.
When someone says _HTML5 game_, the underlying tech is almost always the `<canvas>` element.
On the other hand, non-gaming websites rarely use it.

The cornerstones of the World Wide Web are HTML, CSS and JavaScript.
A typical website amounts to a deep oft-mutated [DOM-tree](https://en.wikipedia.org/wiki/Document_Object_Model) initially induced by HTML, brought to life visually via CSS<SideNote width={220}>CSS supports some core interactivity e.g. [:hover](https://developer.mozilla.org/en-US/docs/Web/CSS/:hover)</SideNote> and interactively using JavaScript<SideNote>Technically, JavaScript permits arbitrary DOM mutation.</SideNote>.
Importantly, CSS allows the browser to behave optimally, and avoids re-inventing the wheel through heavy-duty JavaScript.<SideNote>Although HTMLCanvas is performant via WebGL, the latter is a low-level API.</SideNote>
_Debugging_ is also far richer because one may directly mutate the DOM-tree in a browser devtool.
In contrast, native debugging of `<canvas>` amounts to setting breakpoints inside JavaScript code.

<!-- CSS vs HTMLCanvas i.e. in our approach we can use Chrome devtool -->
<!-- Asymmetry of HTML and JavaScript DOM mutation -->
<!-- Analogy with Web vs App -->
<!-- Want to use Browser Devtool: canonical interface, like CLI -->

üöß Illustrate CSS via devtool video

üöß Please [read the introduction](/intro/). Initially we need a fair amount of exposition.
This reflects our initial work on the "game engine" before we started creating this site.
Partial exposition is indicated by <RoadWorksIcon bottom />.


### Demo

üöß Actions speak louder than words.
Click to navigate or interact (e.g. open doors).
You can drag/scroll/pinch to pan and zoom.
Try resetting (<Icon icon="refresh" small inline />), maximising a tab or all tabs (<Icon icon="expand" small inline />), and disabling (<Icon icon="cross-circle" small inline />).
Show debug circles by typing <InlineCode copy>DEBUG=1; npc config</InlineCode>.

<Tabs
  id="demo-tabs"
  initEnabled={false}
  height={600}
  persistLayout
  initHorizontal
  tabs={[
    [
      { type: 'component', filepath: 'world-demo-1' },
    ],
    [
      { type: 'terminal', filepath: 'demo-1@test', env: { WORLD_KEY: 'world-demo-1', PROFILE: profileLookup['profile-1-a']() } },
    ],
  ]}
/>

### Changelog

| date | change |
| --- | ----------- |
| 2022-??-?? | created [Home page](/) | <!-- |  | created [Introduction](/intro/intro) | -->
|  | created [About](/about) |
|  | created preview [Setup](/intro/setup) |
|  | created preview [JavaScript CLI](/intro/js-cli) |
|  | created preview [Game AI CLI](/intro/ai-cli) |
