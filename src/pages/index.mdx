---
key: index
date: 2023-08-01
info: Home page
# ⛔️ GraphQL error avoided if ≥ 1 instance of field
giscusTerm: /home
label: home
navGroup: null
next: intro/
path: /
prev: null
tags:
  - cli
  - web dev
  - behaviour
  - video games
---

import Carousel from "components/page/Carousel";
import Icon, { RoadWorksIcon } from "components/page/Icon";
import InlineCode from "components/page/InlineCode";
import SideNote from "components/page/SideNote";
import Tabs from "components/page/Tabs";
import Aside from "components/page/Aside";
import { ansi } from "projects/sh/util";

## home

### Introduction

We want to make video games more meaningful. That is the objective of this website. Video games suffer from an underlying problem: **simplistic character behaviour** (NPC as a [meme](https://en.wikipedia.org/wiki/NPC_(meme))). Exceptional games have sidestepped this, some recent examples being:
- [What Remains of Edith Finch](https://en.wikipedia.org/wiki/What_Remains_of_Edith_Finch)
- [Observation](https://en.wikipedia.org/wiki/Observation_(video_game))
- [The Last of Us Part II](https://en.wikipedia.org/wiki/The_Last_of_Us_Part_II) <SideNote>Admittedly very violent, but not in a meaningless way.</SideNote>

The above avoid simplistic behaviour by employing a **tight narrative**, combined with exploration, mini-games and constrained scenarios.
Nevertheless, superficial character behaviour is the norm for video games.<SideNote width={450}>Simplistic behaviour can be "part of the game" e.g. Arcade Games, Puzzles Games.</SideNote><SideNote>On the other hand, even masterpieces like [Quake 1](https://en.wikipedia.org/wiki/Quake_1), [Fallout 2](https://en.wikipedia.org/wiki/Fallout_2), [GTA 2](https://en.wikipedia.org/wiki/GTA_2), [Thief 2](https://en.wikipedia.org/wiki/Thief_2) suffer from simplistic behaviour</SideNote>

<Carousel
  id="first-peek-video"
  height={650}
  mobileHeight={400}
  fullHeight={900}
  items={[{ video: 'first-peek', label: 'First peek' }]}
/>

We believe interesting character behaviour is the lynchpin of meaningful gameplay.
Without it, virtual worlds become stale.
Rather than avoiding the problem by tightening the narrative,
we'd prefer to develop more sophisticated behaviour.
But how?

We have a few core ideas.

{/* > A ghost attracts attention (curiosity).

> NPCs do things in multiple ways (choice).

> NPCs remember and forget (time sensitive).

<Aside title="clarify-sophisticated-behaviour">
  Technically these have all been done many times before.
  For example, an NPC with two attacks already makes choices.
  But these behaviours are rarely freely composable.
  > e.g. a polite NPC might let the Player through a door first (choice),
  and notice something while waiting (curiosity),
  which they later recollect (time sensitive).

  We are interested in combining behaviours,
  whilst maintaining the Player's awareness.
</Aside>

But how are we going to create more sophisticated behaviour? */}
{/* We have a few core ideas. */}

{/* some kinds of "sophisticated" character behaviour may be incompatible with a video game e.g. players replaying scenarios in "Last of Us" may want to repeatability */}

1. Create and combine character behaviours without trying to create a video game.
   
1. Develop differently:
    - Declarative rendering via HTML, CSS and [WAAPI](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Web_Animations_API_Concepts).
    - In-browser scripting via [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18) syntax interpreted as JavaScript.

1. Use openly available assets:
    - Robert Pearce's [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html) and Eric Smith's [PNG format](http://ericbsmith.no-ip.org/geomorphs/).
    - Robert Brook's [Top down men game asset character pack](https://www.gamedeveloperstudio.com/graphics/viewgraphic.php?page-name=Top-down-men-game-asset-character-pack&item=1r6d547z6f232v871n). <SideNote>Not free but `$14.95` (at time of writing) including [Spriter](https://brashmonkey.com/spriter-pro/) source files.</SideNote>

1. Use the [Traveller universe](https://en.wikipedia.org/wiki/Traveller_(role-playing_game)) as background context.<SideNote>The concept of [_Starship Geomorph_](https://wiki.travellerrpg.com/Starship_Geomorphs) comes from Traveller.</SideNote>

Then we intend to approach the problem directly,
by creating and combining behaviours for their own sake.
However, this is a difficult thing to do: we risk creating something neither of **general interest** nor with much **entertainment value**.

<Carousel
  baseSrc="/assets/pics/first-peek/"
  height={550}
  mobileHeight={450}
  fullHeight={800}
  items={[
    { src: 'npcs-1.png', webp: true, label: 'A World (left) and a Terminal (right)' },
  ]}
/>

We tackle _general interest_ in a few ways.

- Our implementation uses _standard_ web development techniques, e.g.
  [CSS](https://en.wikipedia.org/wiki/CSS) and the [Web Animations API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API) for rendering,
  rather than a non-declarative approach invoking [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame).

- Our approach to in-browser scripting is of independent interest.
  We provide an interactive shell interpreting POSIX syntax as JavaScript.<SideNote>Interactively parsed using the wonderful [mvdan-sh](https://github.com/mvdan/sh/tree/master/_js),</SideNote>

- Our CLI ([Command Line Interface](https://en.wikipedia.org/wiki/Command-line_interface)) is extended with generic NPC ([Non-Player Character](https://en.wikipedia.org/wiki/Non-player_character)) shell functions<SideNote>These shell functions give our website its name.</SideNote> e.g. `click`, `spawn`, `look`, `nav`, `walk`.
  They can be naturally piped:
    ```bash
    # walk npc "rob" to clicked navigable points
    click | nav --safeLoop rob | walk rob
    ```

{/* - We consider character behaviour relevant to a vast number of video games. */}

But what about _entertainment value_?
If we're going to make more meaningful video games,
they'd better be more entertaining too.
Additional depth must be seamlessly integrated into the experience.
For example:
- Sometimes deterministic behaviour is desirable to avoid frustrating the Player.
- Complex simulations have little value if they are never witnessed or understood by the Player.

A _Player-centric approach_ will avoid these pitfalls.
There is another important related problem:
although we don't want to create a video game,
**we also don't want an abstract collection of behaviours**.
Thus we provide context on two levels: a setting (Traveller universe) and a narrative container (joining the behaviours together).
The latter is called "The Experiment".

{/* Finally, we must ensure our desire for generality does not produce a dry abstract approach. */}

{/* Entertainment will arise by interacting with our little fabricated worlds. */}
{/* We'll program Non-player Characters ([NPCs](https://en.wikipedia.org/wiki/Non-player_character)) and programming requires patience. */}

<Carousel
  baseSrc="/assets/pics/first-peek/"
  height={600}
  mobileHeight={450}
  fullHeight={800}
  items={[
    { src: 'npcs-2.png', webp: true, label: 'Each World provides a birdsye view.' },
    { src: 'npcs-3.png', webp: true, label: 'Each World is driven by one or more Terminals.' },
  ]}
/>

### Worlds, Players and Terminals

Behaviour arises relative to a _World_.
Defining a World amounts to choosing [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html) and connecting them together.
At present, we only support 5 geomorphs (Robert Pearce provided hundreds) constructed from about 80 [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html)<SideNote>Available in PNG format on [Eric Smith's site](http://ericbsmith.no-ip.org/geomorphs/).</SideNote> (Robert Pearce provided thousands).

<Carousel
  baseSrc="/assets/geomorph/"
  height={450}
  mobileHeight={350}
  fullHeight={800}
  items={[
    { src: 'g-101--multipurpose.map.png', webp: true, label: 'Geomorph 101 (Multipurpose)' },
    { src: 'g-102--research-deck.map.png', webp: true, label: 'Geomorph 102 (Research Deck)' },
    { src: 'g-301--bridge.map.png', webp: true, label: 'Geomorph 301 (Bridge)' },
    { src: 'g-302--xboat-repair-bay.map.png', webp: true, label: 'Geomorph 302 (Xboat Repair Bay)' },
    { src: 'g-303--passenger-deck.map.png', webp: true, label: 'Geomorph 303 (Passenger Deck)' },
  ]}
/>

The thin white rectangles are _doors_. The larger doors on the edges are called _hull doors_.
The geomorphs should be arranged so each hull door either (a) touches nothing else, (b) coincides with exactly one other hull door.
Then we "glue" geomorphs together at their hull doors -- exactly their original purpose.
Below we have combined `101`, `301`, and also `101`, `102`, `303`.

<Tabs
  id="world-map-only"
  initEnabled={false}
  height={[400, 500]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'map-only-1', props: {
          init: { y: 600, zoom: 0.3 },
          worldKey: 'map-only-1',
          gms: [
            { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
            { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
          ],
      }},
      { type: 'component', class: 'World', filepath: 'map-only-2', props: {
          init: { x: 600, y: 600, zoom: 0.3 },
          worldKey: 'map-only-2',
          gms: [
            { gmKey: 'g-101--multipurpose' },
            { gmKey: 'g-102--research-deck', transform: [1, 0, 0, 1, 1200, 0] },
            { gmKey: 'g-102--research-deck', transform: [-1, 0, 0, 1, 0, 0] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, 1, 0, -600] },
            { gmKey: 'g-303--passenger-deck', transform: [1, 0, 0, -1, 0, 600 + 1200] },
          ],
      }},
    ],
  ]}
/>

<Aside title="can-pan-zoom-tabs">
  In the maps above
  you can pan (_drag_),
  you can zoom (_pinch_ or _scroll_),
  and you can drag or maximise their tabs<SideNote>Thanks to the wonderful tabs manager [flexlayout-react](https://www.npmjs.com/package/flexlayout-react).</SideNote>.
  In fact we have just seen two _Worlds_ i.e. [World.js](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/World.jsx "@new-tab") component instances.
  The first map amounts to the following component instantiation:

  ```jsx
  <World
    worldKey="map-only-1"
    gms={[
      { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
      { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
      { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
    ]}
  />
  ```

  The `worldKey` identifies the World's API,
  whereas `gms` specifies the geomorphs and their layout.
  But why do these worlds look like maps?
  > Because there is no _Player_ and thus no _Field Of View_.<SideNote>We already saw the Player-sensitive FOV (Field Of View) in the [video earlier](#first-peek-video).</SideNote>

</Aside>


Our World needs a Player.
This brings us to a very important ingredient, the `<Terminal>`.
Designing user interfaces is _hard_.
Insofar as textual user interfaces are concerned, we've gone the canonical route i.e. [POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html).
Syntactically we provide an interactive shell.
Semantically we manipulate Javascript values and run async generators.

Let's see it in action.
The Terminal's _profile_ explains itself step-by-step,
prompting the user to "tap to continue".
By the way, each `<Terminal>` has a side-menu `<`
particularly helpful for mobile devices.

<Tabs
  id="tabs@world-1"
  initEnabled={false}
  height={[600, 600]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'world-1', props: {
        worldKey: 'world-1',
        init: { zoom: 0.5 , y: 600, ms: 0 },
        gms: [
          { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
          { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
          { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
        ],
      }},
    ],
    [
      { type: 'terminal', filepath: 'tty@world-1', env: {
        WORLD_KEY: 'world-1',
        PROFILE:
`source /etc/util-1
source /etc/game-1

awaitWorld

NOECHO=1 choice "We have ☝️
- defined shell functions
- connected to a world

tap to [ continue ](-)"

spawn rob '{x: -90, y: 1075}'
npc set-player rob
track rob &

NOECHO=1 choice "We have ☝️
- spawned an npc \\"rob\\"
- set them as the Player
- started a follow camera

tap to [ continue ](-)"

npc map hide
goLoop rob &
doLoop rob &
lookLoop rob &

NOECHO=1 echo "Finally we ☝️
- faded the map
- set the Player's controls:
  - tap navmesh (${ansi.Bold}move${ansi.BoldReset})
  - tap doors/icons (${ansi.Bold}do things${ansi.BoldReset})
  - tap elsewhere (${ansi.Bold}look${ansi.BoldReset})"
`
      }},
    ],
  ]}
/>

<Aside title="do-all-the-things">

  Things to try with the World and Terminal above:
  - Open a door.
  - Lie in a bed.
  - Sit on the bog.
  - Reset everything (<Icon icon="refresh" small inline />).
  - Pause everything (<Icon icon="cross-circle" small inline />).
  - Follow the Player by running <InlineCode copy>track rob</InlineCode>.
  - Stop following via Ctrl-C (_kill_ in side menu).
  - List background processes <InlineCode copy>ps</InlineCode>.
  - Kill background processes <InlineCode copy>kill 8 18 26</InlineCode>.<SideNote>You can also pause/resume processes via `--STOP` and `--CONT`</SideNote>
  - List shell functions <InlineCode copy>declare -F</InlineCode>.
  - Inspect a shell script <InlineCode copy>/etc/util-1</InlineCode>.

  <Carousel
    id="do-all-the-things-video"
    height={550}
    mobileHeight={400}
    fullHeight={900}
    items={[{ video: 'do-all-the-things', label: 'Doing all the things' }]}
  />

</Aside>

### Fabricating a behaviour

We're finally ready to create an NPC behaviour.
We need a _World_, the _Player_ and an additional character i.e. _NPC_.<SideNote>Recall NPC stands for Non-Player Character.</SideNote>

🚧
{/* Check out the profile of the terminal below. */}

<Tabs
  id="tabs@world-1+"
  initEnabled={false}
  height={[600, 600]}
  persistLayout
  tabs={[
    [
      { type: 'component', class: 'World', filepath: 'world-1+', props: {
        worldKey: 'world-1+',
        init: { zoom: 0.5 , y: 600, ms: 0 },
        gms: [
          { gmKey: 'g-101--multipurpose', transform: [-1, 0, 0, 1, 1200, 0] },
          { gmKey: 'g-301--bridge', transform: [0, 1, -1, 0, 1200 + 600, 0] },
          { gmKey: 'g-301--bridge', transform: [0, -1, 1, 0, -600, 1200], },
        ],
      }},
    ],
    [
      { type: 'terminal', filepath: 'tty@world-1+', env: {
        WORLD_KEY: 'world-1+',
        PROFILE:
`source /etc/util-1
source /etc/game-1

awaitWorld

NOECHO=1 choice "${ansi.Reverse}${ansi.Bold}So far, this terminal's profile has defined shell functions and connected to world \\$WORLD_KEY.${ansi.Reset}
tap to [ continue ](-)"

spawn rob '{x: -90, y: 1075}'
npc set-player rob
view 1 '{x: -90, y: 1075}' 1.6

NOECHO=1 choice "${ansi.Reverse}${ansi.Bold}Next we've spawned an npc \\"rob\\", set them as the Player and pan-zoomed them into view.${ansi.Reset}
tap to [ continue ](-)"

npc map hide
goLoop rob &
doLoop rob &
lookLoop rob &

NOECHO=1 echo "${ansi.Reverse}${ansi.Bold}Finally we have faded the map and set up the Player's controls."
NOECHO=1 echo
NOECHO=1 echo "ℹ️  tap navmesh (to ${ansi.Bold}move${ansi.BoldReset}), tap nearby doors/icons (to ${ansi.Bold}do things${ansi.BoldReset}), and tap elsewhere (to ${ansi.Bold}look${ansi.BoldReset})."
`
      }},
    ],
  ]}
/>


{/* ```jsx
// internals and return value simplified
export default function NPC({ api, npcKey }) {
  const state = useStateRef(() => {...}); // `api.npcs.npc[npcKey]`

  return (
    <div
      ref={state.npcRef}
      className={`npc ${state.anim.spriteSheet} ...`}
    >
      <div className={`body webp ${state.key}`} />
      <div className="interact-circle" />
      <div className="bounds-circle" />
      <div
        className="head-circle"
        data-meta={JSON.stringify({ npc: true, ui: true, npcKey: state.key })}
      />
    </div>
  );
}
```

Each of the above divs has an associated purpose:
- `div.npc`: translation.
- `div.body`: rotation, opacity, spritesheet.
- `div.interact-circle`: interact radius.
- `div.bounds-circle`: collision radius.
- `div.head-circle`: clickable. */}


{/* Each World instantiates subcomponents including [`<NPCs>`](https://github.com/rob-myers/the-last-redoubt/blob/staging/src/projects/world/NPCs.jsx).
The latter has state `api.npcs` and instantiates each NPC. */}

{/* 🚧 shell command (or _command_)

🚧 game command: command using some World API

🚧 npc behaviour (or _behaviour_): game command using some World npcs API */}

{/* NPC behaviour may be _simulated_ i.e. task-driven imitations of human behaviour. NPC behaviour may be _fabricated_ i.e. specifically constructed in response to the Player's actions. */}
{/* For example, if the Player enters a particular room we could spawn enemies (fabrication) which are instructed to chase after the Player (simulation). */}

{/* By this we mean an interactive [Command Line Interface](https://en.wikipedia.org/wiki/Command-line_interface) running in the browser.
Graphically it amounts to [Xterm.js](https://github.com/xtermjs/xterm.js#readme).<SideNote>Keypresses are handled by our own analog of [Readline](https://en.wikipedia.org/wiki/GNU_Readline).</SideNote>
Programmatically it interprets POSIX shell syntax as JavaScript and executes it.<SideNote>We parse shell syntax using the wonderful [mvdan-sh](https://www.npmjs.com/package/mvdan-sh).</SideNote>
Supported syntax includes shell pipelines, shell functions and background processes.*/}

{/* <Aside title="interpret-js">

But how is shell syntax interpreted as JavaScript?

> Consider our shell function `call`.<br/>
> Given a textual description of a JavaScript function and its arguments, it creates the JavaScript function and its arguments, and finally invokes this function with these arguments.

As another example, the shell builtin `run` creates and iterates a JavaScript [AsyncGenerator function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function*).
The shell functions `call`, `map`, `range` and `split` (above) are all defined in terms of `run`.

</Aside> */}

{/* There are two basic ways to create browser-based video games:
[HTMLCanvasElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement) and
[CSS](https://developer.mozilla.org/en-US/docs/Web/CSS).
The `<canvas>` amounts to an image we can manipulate via JavaScript.
We can fill shapes, put pixels, or even [render 3D worlds](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API) at 60 frames per second.
When someone says _HTML5 game_, the underlying tech is almost always the `<canvas>` element.
On the other hand, non-gaming websites rarely use it.

The cornerstones of the World Wide Web are HTML, CSS and JavaScript.
A typical website amounts to a deep [DOM-tree](https://en.wikipedia.org/wiki/Document_Object_Model) initially induced by HTML, brought to life _visually_ via CSS <SideNote>e.g. `<link>` and `<style>` nodes</SideNote> and _interactively_ via JavaScript<SideNote>Technically, JS permits arbitrary DOM mutation.</SideNote>.
Concerning CSS, web browsers interpret it very efficiently.
Its declarative approach avoids re-inventing the wheel via heavy-duty JavaScript.<SideNote>Although HTMLCanvas is performant via [WebGL](https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API), the latter is a low-level API.</SideNote>
Finally, CSS permits _rich interactive debugging_.
That is, one may directly mutate the DOM-tree in a browser devtool,
whereas debugging `<canvas>` amounts to setting breakpoints inside JavaScript code. */}

{/* We want to program NPCs, producing a catalogue of interesting behaviours.
We are particularly interested in studying how they can be composed in response to the Player's actions.
However, NPC behaviours need to be studied at the right level of abstraction.
We are not trying to create _middleware_.
We do not want to create a generic Game AI system, upon which "real games" can be scaffolded.
_Why?_
Because NPC behaviour is highly contextual.
It is usually brought to life via assets representing a specific situation: suitable background scenery and animations of particular denizens.

We definitely need this _spice_ i.e. assets and animations which bring our NPCs to life.
> Thankfully we can use [Starship Geomorphs](http://travellerrpgblog.blogspot.com/2020/07/starship-geomorphs-20.html "@new-tab") by Robert Pearce,
> a large number of aerial-view assets representing Starships, Space-stations, Space-colonies etc.
*/}

{/* ### Changelog

| date | change |
| --- | ----------- |
| 2022-??-?? | created [Home page](/) |
|  | created [About](/about) |
|  | created preview [Setup](/intro/setup) |
|  | created preview [JavaScript CLI](/intro/js-cli) |
|  | created preview [Game AI CLI](/intro/ai-cli) | */}
