---
key: intro
path: /intro
info: Introduction
label: Introduction
date: 2022-08-01
navGroup: 0
prev: index
next: intro/project
tags:
  - objective
  - game ai
  - video game
  - web dev
---

import Video from "components/page/Video";
import Tabs from "components/page/Tabs";
import Icon from "components/page/Icon";
import ImageCarousel from "components/page/ImageCarousel";
import InlineCode, { InlineUniCode } from "components/page/InlineCode";
import { profileLookup } from "projects/sh/scripts";

## Motivation

What's this website about?

> **Making Game AI** i.e. controlling [NPCs](https://en.wikipedia.org/wiki/Non-player_character) in video games.

NPC stands for _Non-Player Character_ - 
every friendly or unfriendly character except for the Player.
Their behaviour shapes the game, steadily drawing the Player into the fabrication.
Then our motivation is _lacklustre NPC behaviour in modern video games_.
Can we clarify the problem?
Can we do better?

Sometimes Game AI is emergent.
For example, Super Mario 3 arises from many individual independent NPC behaviours running in parallel.
But for anything beyond [Koopa Troopas](https://en.wikipedia.org/wiki/Koopa_Troopa) (fixed patrol route) or [Boo Diddleys](https://en.wikipedia.org/wiki/Boo_(character)) (approach Player when unseen),
the result is usually a mess.
The _combinatorial explosion of possibilities_ results in
unrealistic hard-to-debug behaviour.

Focusing on what the Player actually experiences is a better idea.
Everything except the Player is the _environment_, controlled by a highly opinionated _Director_ (an amalgam of people and software).
The Director controls the environment (including the NPCs), and the Player has certain freedoms within it.
But the Director needs something to direct,
so we must **create a game** to make meaningful Game AI.


### Tech stack

We're writing about Game AI and also creating a game.
Then it's natural to use web technologies, building the game right here on this site.
But which ones?

> We'll use **everyday web dev tech** e.g. [CSS](https://en.wikipedia.org/wiki/CSS), [React](https://en.wikipedia.org/wiki/React_(JavaScript_library)#Functional_components), [Node.js](https://en.wikipedia.org/wiki/Node.js).
>
> We'll avoid game-centric tech like Flash, HTMLCanvas frameworks, CSS 3D transforms, WebGL,
> and JavaScript-driven rendering or simulation.

This makes our approach relevant to a wide audience.


### Building the world

To create a game we must _create a world_.
A setting and characters are needed as guiding principles,
not necessarily as driving forces.

Our setting is _The Last Redoubt_, a gigantic pyramid protecting the last of humanity, as described in [The Night Land](https://en.wikipedia.org/wiki/The_Night_Land) (1912).
We mention two characters: Andros (the protagonist) and Cartesius (his preceptor);
these names come from [The Night Land, A Story Retold](https://en.wikipedia.org/wiki/The_Night_Land#Pastiche,_homages_and_sequels) (2011).
But how to fabricate this pyramid?
How should we build The Last Redoubt?

> Thankfully we've done the groundwork, as shown in the videos below.

<Video videoKey="intro-first-videos" />

<aside title="starship-geomorphs">

  The graphics above depict Geomorph 301 (a.k.a. _Bridge_) from Robert Pearce's [Starship Geomorphs 2.0](http://travellerrpgblog.blogspot.com/2018/10/the-starship-geomorphs-book-if-finally.html).
  Actually, we've recreated it using 9 of his [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html).
  These wonderful assets provide one of the foundation stones upon which our game is built.

</aside>

It is worth taking some time to make a few observations about the above videos.

> **The game has a birdseye viewpoint**.
> Avoiding game-centric tech rules out 3D graphics (except isometric).

> **The Player moves by navigating the [navmesh](https://en.wikipedia.org/wiki/Navigation_mesh#:~:text=A%20navigation%20mesh%2C%20or%20navmesh,video%20game%20AI%20in%202000.), opening nearby doors**.
> Mouse clicks are converted into world coordinates.
> Doors are styled clickable [divs](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement).

> **The Player interacts via mouse clicks or touches**.
> We avoid game-centric controls, using standard site interaction instead.

> **The Player is _situated_ with limited visual range**.
> We achieve this using two copies of the [same PNG](/geomorph/g-301--bridge.png "@new-tab") (one atop the other).
> The top one is inverted ([CSS filter](https://developer.mozilla.org/en-US/docs/Web/CSS/filter)) and masked ([CSS clip-path](https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path)).

The camera ([CSS transforms](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)) further restricts what can be seen, although one can peek by panning and zooming.
We've illustrated these points below.

<ImageCarousel
  id="intro-video-frames"
  width={200}
  height={400}
  peekWidth={80}
  baseSrc="/pics/intro-carousel/"
  items={[
    { src: 'birdseye.png', label: 'Birdseye Viewpoint' },
    { src: 'open-nearby-door.png', label: 'Open door via click/touch' },
    { src: 'click-navmesh.png', label: 'Click navmesh to walk' },
    { src: 'enter-door.png', label: 'Entering door changes view'},
    { src: 'can-go-round-corners.png', label: 'Navigate around corners' },
    { src: 'open-door-see-more.png', label: 'Open door & see more' },
    { src: 'pan-zoom-see-more.png', label: 'Pan-zoom to peek' },
  ]}
  blur
  imgStyles={{ marginTop: '-24px', height: 'calc(100% + 24px)' }}  // Crop
  labelTop="10%"
/>

So our approach uses [everyday web dev tech](#intro--tech-stack "@anchor") as promised.
We'll interact with the real McCoy in the next section.
For those itching to see how it is built, check out [this CodeSandbox](https://codesandbox.io/s/tty-world-1-0s9wfl?file=/src/index.js "@new-tab").

### Directing the world

Let's recall our motivation:
> understanding and improving Game AI.

Rather than rely on Player-interaction with independent parallel systems,
we'll intentionally modify the Player's experience.
Examples include:
- Spawn enemy when Player walks through 3 doors.
- Build tension by showing enemies at fringes of vision.
- Tempt Player to particular area and ambush them.
- Indicate room purpose via ghostly replay.
- Orchestrate enemy search party.

We've made good progress towards _building_ a world,
but what about _directing it_ (e.g. specifying the behaviour of NPCs)?

> The [videos above](#intro-first-videos "@anchor") show a [_terminal_](https://xtermjs.org/ "@new-tab") (the black window with mostly green text).
We can type commands and press enter to run them.
Commands are parsed using the excellent [mvdan-sh](https://www.npmjs.com/package/mvdan-sh),
and then interpreted by our own specially written interpreter.
Collectively they convert POSIX-like commands into JavaScript and execute it.

> If Game AI (NPC behaviour) is the interaction between the Director (human-software amalgam) and the Player,
**the Director directs by running commands in one or more terminals**.
These commands may include scripts and long-running processes.

Let's see an example.

1. Try clicking _interact_ below.

   After a few lines, you'll see repetitions __polling for cached query__
   (if not, click reset <Icon icon="refresh" small inline />).
   Clicking disable <Icon icon="cross-circle" small inline />,
   you'll see __paused session__ and the _interact_ button returns.

2. Press _interact_ again, and this time click on the 2nd tab.
   You'll see the world from the videos, we suggest you have a play around.

<Tabs
  id="intro-1"
  initEnabled={false}
  height={500}
  tabs={[
    [
      {
          type: 'terminal',
          filepath: 'intro-tty-1',
          env: { WORLD_KEY: 'intro-world-1', PROFILE: profileLookup['profile-1-a']() },
      },
      { type: 'component', filepath: 'intro-world-1' },
    ],
  ]}
  initHorizontal
  // persistLayout
/>

3. Finally return to the 1st tab and scroll to the top.

  | Line | Info |
  | --- | ----------- |
  | <InlineUniCode>ℹ️</InlineUniCode>`  Running /home/PROFILE` | The absolute path <InlineCode>/home/PROFILE</InlineCode> refers to a string (the terminal's initialisation script). Try typing it into the terminal, or click and paste (easier on a mobile). |
  | `source /etc/util-1` | The 1st line of the string at `/home/PROFILE`. This command executes the string at <InlineCode>/etc/util-1</InlineCode> which defines util functions. |
  | `source /etc/game-1` | From `/home/PROFILE`, <InlineCode>/etc/util-1</InlineCode> defines game-related functions. List all functions via <InlineCode>declare</InlineCode>. |
  | `await-world` | From `/home/PROFILE`, this command awaits a world whose identifier is the string at <InlineCode>/home/WORLD_KEY</InlineCode>. While polling it sends lines, as we saw. |

  What about the rest of `/home/PROFILE`?
  > It spawns Andros, sets him as the Player,
  > and finally initiates 3 long-running background processes.
  > That is,
  > (a) the camera tracks Andros,
  > (b) clicking the navmesh makes him walk,
  > (c) clicking outside the navmesh makes him turn.

<aside>

  Our [shell](https://en.wikipedia.org/wiki/Shell_(computing)#Command-line_shells) wraps JavaScript in a Command Line Interface.
  JavaScript is concerned with **values** (primitive or object) rather than files.
  Each terminal has an associated root object where
  e.g. `root.home.PROFILE` is a string defining the initialisation script.
  Shells usually don't echo the initialisation script.
  Ours pastes it into the terminal, producing the above behaviour.

</aside>

We've also recorded the above example on desktop and mobile.

<Video videoKey="intro-world-tty-videos" />

### Finished product

Game developers suffer from a disease.
They intend to make a game yet make a _game engine_ instead
(i.e. supporting systems sans unification).
This is a _real problem_ - years of effort with zero result.
However, our driving force is Game AI rather than publishing a game.
We'll avoid _zero result_ by publishing the stepwise process right here.
It is relevant to a wide audience: _web developers_.

We don't believe Game AI can be studied abstractly.
It rarely overlaps with the academic subject known as Artificial Intelligence.
But we shouldn't forget the [Turing Test](https://en.wikipedia.org/wiki/Computing_Machinery_and_Intelligence) was originally a gender-bending party game.
In this sense, believable NPC behaviour can be viewed as a kind of Artificial Intelligence.
We needn't identify AI with _Computer Vision_ or _Driverless Vehicles_ (impressive as they are).

Lacking an abstract approach, we see no other alternative that embedding Game AI into a game.
Then what's our game going to be?

> **Setting**.
> A gargantuan pyramid housing the last of Earth's humanity, millions of years after the Sun has died. This structure is known as [The Last Redoubt](https://en.wikipedia.org/wiki/The_Night_Land).

> **Story overview**.
> Andros must defend the pyramid against invaders: _mental effluents_ and _unnatural incarnations_ who've broken through the Air Clog.

> **Influences**.
> 1. [Teleglitch](https://en.wikipedia.org/wiki/Teleglitch "@new-tab").
> A top-down survival-horror combat-heavy roguelike.
> 1. [Fallout 1 & 2](https://en.wikipedia.org/wiki/Fallout_(video_game) "@new-tab").
> Oblique-projected turn-based quest/combat-driven open-world RPGs.
> 1. [GTA 1 & 2](https://en.wikipedia.org/wiki/Grand_Theft_Auto_(video_game)).
> Top-down mission/combat-based open-world action games.
>
> Teleglitch (2013) provides the strongest influence.
The protagonist must escape through ~10 levels of a military base (every NPC is hostile).
The top-down line-of-sight view coupled with sound-design, sparse resources, and combat-difficultly produce a feeling of dread.
> Fallout 1 & 2 and GTA 1 & 2 are breathtakingly good open-world games from the late nineties.
They serve as reference points and continual sources of inspiration.


__TODO__
- Description of first mission
- How we'll iterate on the Game AI