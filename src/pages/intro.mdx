---
key: intro
path: /intro
info: Introduction
label: Introduction
date: 2022-08-01
navGroup: null
prev: null
next: null
tags:
  - objective
  - game ai
  - video game
  - web dev
---

import Tabs from "components/page/Tabs";
import Icon from "components/page/Icon";
import ImageCarousel from "components/page/ImageCarousel";
import InlineCode from "components/page/InlineCode";
import { profileLookup } from "projects/sh/scripts";

## Introduction

### Motivation

What's this website about?

> **Making Game AI** i.e. controlling [NPCs](https://en.wikipedia.org/wiki/Non-player_character) in video games.

NPC stands for _Non-Player Character_ - 
every friendly or unfriendly character except for the Player.
They must behave realistically, steadily drawing the Player into the fabrication.
Then our motivation is the _lacklustre NPC behaviour in modern video games_.
Can we clarify the problem?
Can we do better?

Sometimes Game AI is emergent.
For example, Super Mario 3 arises from many independent individual NPC behaviours running in parallel.
But for anything beyond [Koopa Troopas](https://en.wikipedia.org/wiki/Koopa_Troopa) (fixed patrol route) or [Boo Diddleys](https://en.wikipedia.org/wiki/Boo_(character)) (approach Player when unseen),
the result is usually a mess.
The _combinatorial explosion of possibilities_ results in
unrealistic hard-to-debug behaviour.

Focusing on what the Player actually experiences is a better idea.
There's the Player and there's the _environment_, controlled by a highly opinionated _Director_ (an amalgam of people and software).
The Director controls the environment (e.g. all the NPCs), and the Player has certain freedoms within it.
But the Director needs something to direct,
so we must **create a game** to make meaningful Game AI.


### Tech stack

We're writing about Game AI and also creating a game.
Then it's natural to use web technologies, building the game right here on this site.
But which ones?

> We'll use **everyday web dev tech** e.g. [CSS](https://en.wikipedia.org/wiki/CSS), [React](https://en.wikipedia.org/wiki/React_(JavaScript_library)#Functional_components), [Node.js](https://en.wikipedia.org/wiki/Node.js).
>
> We'll avoid game-centric tech like Flash, HTMLCanvas frameworks, CSS 3D transforms, WebGL,
> and JavaScript-driven rendering or simulation.

This makes our approach relevant to a much wider audience.


### Building the world

We need characters and a world they inhabit.
Our setting is _The Last Redoubt_, a gigantic pyramid protecting the last of humanity, as described in [The Night Land](https://en.wikipedia.org/wiki/The_Night_Land) (1912).
We mention two characters: Andros (the protagonist) and Cartesius (his preceptor);
these names come from [The Night Land, A Story Retold](https://en.wikipedia.org/wiki/The_Night_Land#Pastiche,_homages_and_sequels) (2011).
But how to build it?
How should we build The Last Redoubt?

> Thankfully we've done the groundwork, as shown in the videos below.

<iframe className="youtube" width="100%" height="464" src="https://www.youtube.com/embed/videoseries?list=PLTcU-Qpr40X6hq3GSbY8K92DR_DUSgzim" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<aside title="starship-geomorphs">

  The graphics above depict Geomorph 301 (a.k.a. _Bridge_) from Robert Pearce's [Starship Geomorphs 2.0](http://travellerrpgblog.blogspot.com/2018/10/the-starship-geomorphs-book-if-finally.html).
  Actually, we've recreated it using 9 of his [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html).
  These wonderful assets provide one of the foundation stones upon which our game is built.

</aside>

So our game has a birdseye viewpoint.
The Player moves by navigating the [navmesh](https://en.wikipedia.org/wiki/Navigation_mesh#:~:text=A%20navigation%20mesh%2C%20or%20navmesh,video%20game%20AI%20in%202000.) and opening nearby doors.
These actions are achieved by clicking the mouse or touching the screen.
The Player is _situated_ i.e. their awareness is limited by their current position.
The camera further restricts what can be seen, although one can peek by panning and zooming.
Let's summarise with some slides.

<ImageCarousel
  id="intro-video-frames"
  width={200}
  height={400}
  peekWidth={80}
  baseSrc="/pics/intro-carousel/"
  items={[
    { src: 'birdseye.png', label: 'Birdseye Viewpoint' },
    { src: 'open-nearby-door.png', label: 'Open door via click/touch' },
    { src: 'click-navmesh.png', label: 'Click navmesh to walk' },
    { src: 'enter-door.png', label: 'Entering door changes view'},
    { src: 'can-go-round-corners.png', label: 'Navigate around corners' },
    { src: 'open-door-see-more.png', label: 'Open door & see more' },
    { src: 'pan-zoom-see-more.png', label: 'Pan-zoom to peek' },
  ]}
  blur
  imgStyles={{ marginTop: '-24px', height: 'calc(100% + 24px)' }}  // Crop
  labelTop="10%"
/>

We [mentioned](#intro--tech-stack "@anchor") our restriction to standard web dev techniques.
For example, the lighting above is achieved via two copies of the same PNG.
The top one is inverted via [CSS filter](https://developer.mozilla.org/en-US/docs/Web/CSS/filter) and masked by [CSS clip-path](https://developer.mozilla.org/en-US/docs/Web/CSS/clip-path).
We'll play the actual game in the next subsection.
For those itching to see how it is built, [check out this CodeSandbox](https://codesandbox.io/s/tty-world-1-0s9wfl?file=/src/index.js "@new-tab").

### How to direct

Importantly, the videos above show a [_terminal_](https://xtermjs.org/) (the black window with mostly green text).
We can type commands into it and press enter to run them.
Commands are parsed using the excellent [mvdan-sh](https://github.com/mvdan/sh),
and then interpreted by our own specially written interpreter.
Collectively they convert POSIX-like commands into JavaScript and execute it.

The terminal is central to our approach.
We view Game AI (NPC behaviour) as interaction between the Director and the Player.
In our approach, the Director _directs_ by running commands in one or more terminals,
including scripts and long-running processes.
Let's see an example.

1. Try clicking _interact_ below.

   After a few lines, you'll see repetitions __polling for cached query__
   (if not, click reset <Icon icon="refresh" small inline />).
   Clicking disable <Icon icon="cross-circle" small inline />,
   you'll see __paused session__ and the _interact_ button again.

2. Press _interact_ again, and this time click on the 2nd tab.
   You'll see the world from the videos.
   Maybe have a play around, re-enacting what you've seen.

<Tabs
  id="intro-1"
  initEnabled={false}
  height={500}
  tabs={[
    [
      {
          type: 'terminal',
          filepath: 'intro-tty-1',
          env: { WORLD_KEY: 'intro-world-1', PROFILE: profileLookup['profile-1-a']() },
      },
      { type: 'component', filepath: 'intro-world-1' },
    ],
  ]}
  initHorizontal
  // persistLayout
/>

3. Finally return to the 1st tab (or drag them apart),
   scrolling to the top if necessary.
   Then:
   - <InlineCode>/home/PROFILE</InlineCode> is the string defined the initial script. Try copy-pasting it into the terminal.
   - ok


### What to direct

<!-- Each terminal initially runs a script - its _profile_.

Let us begin by entering `/home/PROFILE` into the terminal. -->

<!-- Now, video games are a _lot of work_.
There's the story, characters, graphical style, user interface, assets, animation, level design, scripting and NPC behaviour.
Many systems must be created, collectively forming a cohesive whole.
One popular approach takes inspiration from films.
That is, the _story_ and _characters_ (including the player) sit on the podium, and the other systems bring them to life.

> To put Game AI on the podium, we've chosen a different role model:
>
> Web Development.

Web Development is a particular kind of Software Development.
It uses special purpose languages i.e. HTML, CSS and JavaScript.
We'll develop our game using the _everyday practices_ of a Web Developer.
This rules out game-centric technologies like Flash, Game Frameworks, CSS 3D transforms, and WebGL.
But it also makes our approach relevant to a wide audience. -->

<!-- TODO not just using Web as a platform; we're using it as a dev env too -->

<!-- Concerning the game systems, we've done the groundwork already.
This is just as well, else our investigation of Game AI would be on the distant horizon.
Consider the component below: -->

<!--
- This doesn't mean the story and characters are unimportant.
- We do not mean "use the Web as a platform"
-->
