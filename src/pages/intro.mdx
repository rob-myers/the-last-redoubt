---
key: intro
path: /intro
info: Introduction
label: Introduction
date: 2022-08-01
navGroup: null
prev: null
next: null
tags:
  - objective
  - game ai
  - video game
  - web dev
---

import Tabs from "components/page/Tabs";
import ImageCarousel from "components/page/ImageCarousel";
import { profileLookup } from "projects/sh/scripts";

## Introduction

### Motivation

What's this website about?

> Game AI.

We want to understand and improve Artificial Intelligence (AI) in [_video games_](https://en.wikipedia.org/wiki/Video_game).
The latter amounts to a loose collection of algorithms and data structures for controlling [NPCs](https://en.wikipedia.org/wiki/Non-player_character).
These Non-Player Characters must behave realistically,
steadily drawing the Player into the fabrication.

Reading Game AI tutorials, one can get the impression that believable behaviour just _emerges_ from the right ingredients.
Given NPCs with their own desires and strategies, we can certainly run them in parallel with the Player.
But for anything beyond [Koopa Troopas](https://en.wikipedia.org/wiki/Koopa_Troopa) or [Boo Diddleys](https://en.wikipedia.org/wiki/Boo_(character)), the result is a mess.
The _combinatorial explosion of possibilities_ inevitably yields
unrealistic and unpredictable behaviour.

Focusing on what the Player actually experiences is a better idea.
There's the Player and there's the _environment_, controlled by a highly opinionated _Director_ (an amalgam of people and software).
The Director and Player interact via the environment.
The Director controls it and the Player has certain degrees of freedom within it.
But the Director needs something to direct,
so we must **create a game** to make meaningful Game AI.


### Approach to web development

We're investigating Game AI and also creating a game.
Then it is natural to use web technologies, building the game right here on this site.
But which web technologies?

> We'll use **everyday web developer techniques**.
>
> This excludes game-centric technology like Flash, HTMLCanvas frameworks, CSS 3D transforms, and WebGL.
> It also excludes JavaScript-driven rendering and simulation.

Importantly, this makes our approach relevant to a much wider audience.


### Building a world

We need narratives and characters and a world they inhabit.
Our setting is _The Last Redoubt_, a gigantic pyramid protecting the last of humanity, as described in [The Night Land](https://en.wikipedia.org/wiki/The_Night_Land) (1912).
We mention two characters: Andros (the protagonist) and Cartesius (his preceptor);
these names come from [The Night Land, A Story Retold](https://en.wikipedia.org/wiki/The_Night_Land#Pastiche,_homages_and_sequels) (2011).
Our chosen overarching narrative will be familiar: defend the pyramid from invading forces.
But how to build it?
How should we build The Last Redoubt?

> Thankfully we've done the groundwork, as shown in the videos below.

<iframe className="youtube" width="100%" height="464" src="https://www.youtube.com/embed/videoseries?list=PLTcU-Qpr40X6hq3GSbY8K92DR_DUSgzim" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<aside>

  Above we've used Geomorph 301 (a.k.a. _Bridge_) from Robert Pearce's [Starship Geomorphs 2.0](http://travellerrpgblog.blogspot.com/2018/10/the-starship-geomorphs-book-if-finally.html).
  Actually, we've recreated it using 9 of his [Starship Symbols](http://travellerrpgblog.blogspot.com/2020/08/starship-symbols-book.html).
  These wonderful assets provide one of the foundation stones upon which our game is built.

</aside>

Our game has a birdseye viewpoint.
The Player moves by navigating the [navmesh](https://en.wikipedia.org/wiki/Navigation_mesh#:~:text=A%20navigation%20mesh%2C%20or%20navmesh,video%20game%20AI%20in%202000.) and opening nearby doors.
These actions are achieved by clicking the mouse or touching the screen.
The Player is _situated_ i.e. their vision is limited by their current position.
The camera further restricts what can be seen, although one can peek by panning and zooming.
The videos also show some kind of _terminal_,
but first we summarise with some slides.

<ImageCarousel
  id="intro-video-frames"
  width={300}
  height={550}
  baseSrc="/pics/intro-carousel/"
  items={[
    { src: 'birdseye.png', label: 'Birdseye Viewpoint' },
    { src: 'open-nearby-door.png', label: 'Open door via click/touch' },
    { src: 'click-navmesh.png', label: 'Click navmesh to walk' },
    { src: 'enter-door.png', label: 'Entering door changes view'},
    { src: 'can-go-round-corners.png', label: 'Navigate around corners' },
    { src: 'open-door-see-more.png', label: 'Open door & see more' },
    { src: 'pan-zoom-see-more.png', label: 'Pan-zoom to peek' },
  ]}
  imgStyles={{ marginTop: '-24px', height: 'calc(100% + 24px)' }}  // Crop
  labelTop="10%"
/>

Let's turn to the [terminal](https://xtermjs.org/) i.e.
that black pane with mostly green text.
When prompted by `$` we may type commands into it and press _enter_ to run them.
What does this mean?
Well, to _run_ a command we (a) [parse it](https://en.wikipedia.org/wiki/Parsing#Computer_languages), and (b) interpret it e.g. invoke functions previously defined by the system or user.
We use the excellent [mvdan-sh](https://github.com/mvdan/sh) to parse commands,
and then apply our own specially written interpreter.
Collectively, the parser and interpreter convert POSIX-like commands into JavaScript and execute it.

The terminal lies at the heart of our approach to Game AI.
We view Game AI (NPC behaviour) as interaction between the Director and the Player.
In our approach, the Director _directs_ by running commands in a terminal.
These commands may include scripts and long-running processes.
For example each terminal runs a script initially -- its _profile_.
Here's a live example.

<Tabs
  id="intro-1"
  initEnabled={false}
  height={500}
  tabs={[
    [{ type: 'component', filepath: 'intro-world-1' }],
    [{
        type: 'terminal',
        filepath: 'intro-tty-1',
        env: { WORLD_KEY: 'intro-world-1', PROFILE: profileLookup['profile-1-a']() },
    }],
  ]}
  initHorizontal={true}
/>

Let us begin by entering `/home/PROFILE` into the terminal.

<!-- Now, video games are a _lot of work_.
There's the story, characters, graphical style, user interface, assets, animation, level design, scripting and NPC behaviour.
Many systems must be created, collectively forming a cohesive whole.
One popular approach takes inspiration from films.
That is, the _story_ and _characters_ (including the player) sit on the podium, and the other systems bring them to life.

> To put Game AI on the podium, we've chosen a different role model:
>
> Web Development.

Web Development is a particular kind of Software Development.
It uses special purpose languages i.e. HTML, CSS and JavaScript.
We'll develop our game using the _everyday practices_ of a Web Developer.
This rules out game-centric technologies like Flash, Game Frameworks, CSS 3D transforms, and WebGL.
But it also makes our approach relevant to a wide audience. -->

<!-- TODO not just using Web as a platform; we're using it as a dev env too -->

<!-- Concerning the game systems, we've done the groundwork already.
This is just as well, else our investigation of Game AI would be on the distant horizon.
Consider the component below: -->

<Tabs
  id="intro-2"
  initEnabled={false}
  height={600}
  tabs={[
    [{ type: 'component', filepath: 'intro-world-2' }],
    [{
        type: 'terminal',
        filepath: 'intro-tty-2',
        env: { WORLD_KEY: 'intro-world-2', PROFILE: profileLookup['profile-1-a']() },
    }],
  ]}
/>


- What do we mean?
- This doesn't mean the story and characters are unimportant.
- But when _Game AI_ plays second fiddle to _Story_ ...
- We do not mean "use the Web as a platform"
- We do not mean "Web Games" like Flash, WebGL etc.
- Story and Characters still sit on podium


<!-- TODO alignment with web dev -->

<!-- TODO bring Tabs into this early -->